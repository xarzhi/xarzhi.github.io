# 组件传值

## 1.defineProps()

Vue3中父组件向子组件传值扔和Vue2一样，但子组件接受的方式不一样

在Vue3中需要使用`defineProps()`，其传入的参数与选项式Api的props一致

`defineProps` 是只能在 `<script setup>` 中使用的**编译器宏**。他们不需要导入，且会随着 `<script setup>` 的处理过程一同被编译掉。

### 1.1 props校验

父组件传递数据

```vue
<Child :num="123" :name="坤坤"></Child>
```

子组件接受数据，数组形式

```js
const props=defineProps(['num','name'])
```

对象形式-可限制类型

```js
const props=defineProps({
    num:Number,
    name:String
})
```

详细对象形式-可限制类型、必要性、默认值

```js
const props=defineProps({
    num:{
        type:Number,
        default:0
    },
    name:{
        type:String,
        require:true
    }
})
```

详细对象形式还可以校验

```js
const props = defineProps({
    num:{
        validator(value,props){
			return value > 60 ? "及格" : "不及格"
        }
    },
})
```



### 1.2 props解构

上述写法我们使用props中的值需要使用`props.键`使用

通过解构可以方便使用 

```js
const {num,name} = defineProps(['num','name'])
```





## 2.defineEmits()

defineEmits()用于组件的自定义事件，defineEmits()也不需要导入就可以直接使用

defineEmits()接受一个数组，数组中包含多个自定义事件名

:::code-goup

```vue [Father.vue]
<template>
  <Child @emitEvent="add"></Child>
</template>

<script setup>
const add=(num,num1)=>{
	console.log(num+num1)
}
</script>
```

```vue [Child.vue]
<script setup>
   const emit = defineEmits(['emitEvent'])
   emit('emitEvent',11,22)
</script>
```

:::





## 3.defineExpose()

当父组件通过ref获取子组件实例时，默认子组件中的数据时获取不到的，需要使用`defineExpose()`将数据暴露出去

`defineExpose()`接受一个对象，对象中包含需要暴露出去的数据

:::code-group

```vue [Child.vue] {13}
<template>
  {{ num }}
</template>

<script setup>
import { ref } from 'vue'
    
const num = ref(666)
const add = () => {
  console.log(num.value * 100)
}

defineExpose({ num, add })
</script>
```

```vue [Father.vue] {3,12,14-17}
<template>
  <div>
    <Child ref="child"></Child>
    <button @click="show">click</button>
  </div>
</template>

<script setup>
import Child from './views/Child.vue'
import { ref } from 'vue'

const child = ref(null)

const show = () => {
  child.value.num = 777
  child.value.add()
}
</script>
```

:::





## 4.defineModel()

`defineModel()`在3.4+引入

`defineModel()`可获取`v-model`传过来的值，用于**双向绑定**，并不需要导入就可以使用

:::code-group

```vue [Father.vue] {3}
<template>
  <div>
    <Child v-model="num"></Child>
  </div>
</template>

<script setup>
import Child from './views/Child.vue'
import { ref } from 'vue'

const num = ref(123)
</script>
```

```vue [Child.vue] {11,14}
<template>
  <div>
    {{ num }}
    <button @click="add">add</button>
  </div>
</template>

<script setup>
import { defineModel } from 'vue'

const num = defineModel()

const add = () => {
  num.value++
}
</script>
```

:::

`defineModel()`可以传入一个对象，格式与`defineProps()`的参数相同，

也可以传入一个字符串，用于给`v-mode`传来的值取别名，此时第二个参数为一个对象



### 4.1 修饰符

通过如下方式获取v-model修饰符

:::code-group

```vue [Father.vue]
<Child v-model.trim="num"></Child>
```

```vue [Child.vue]
<script setup>
const [num, opt] = defineModel()
if ( opt.trim ) {
	// ...
}
</script>
```

:::



### 4.2 转换器

当存在修饰符时，我们可能需要在读取或将其同步回父组件时对其值进行转换。我们可以通过使用 `get` 和 `set` 转换器选项来实现这一点：

```js
const [modelValue, modelModifiers] = defineModel({
  // get() 省略了，因为这里不需要它
  set(value) {
    // 如果使用了 .trim 修饰符，则返回裁剪过后的值
    if (modelModifiers.trim) {
      return value.trim()
    }
    // 否则，原样返回
    return value
  }
})
```









