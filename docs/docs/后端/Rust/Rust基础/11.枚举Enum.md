# 枚举

枚举也被称作 *`enums`*。枚举允许你通过列举可能的 **成员**（*variants*） 来定义一个类型。

枚举是一个很多语言都有的功能，不过不同语言中其功能各不相同。Rust 的枚举与 F#、OCaml 和 Haskell 这样的函数式编程语言中的 **代数数据类型**（*algebraic data types*）最为相似。

## 1.基本使用

### 1.1 定义枚举

任何一个 IP 地址要么是 IPv4 的要么是 IPv6 的，而且不能两者都是。

IP 地址的这个特性使得枚举数据结构非常适合这个场景，因为枚举值只可能是其中一个成员。

```rust
enum IpAddrKind {
    V4,
    V6,
}
```

可以通过在代码中定义一个 `IpAddrKind` 枚举来表现这个概念并列出可能的 IP 地址类型，`V4` 和 `V6`。这被称为枚举的 **成员**（*variants*）,也叫做**变体**

现在 `IpAddrKind` 就是一个可以在代码中使用的自定义数据类型了。



### 1.2 枚举值

可以像这样创建 `IpAddrKind` 两个不同成员的实例：

```rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```

注意枚举的成员位于其标识符的命名空间中，并使用两个冒号分开。这么设计的益处是现在 `IpAddrKind::V4` 和 `IpAddrKind::V6` 都是 `IpAddrKind` 类型的。例如，接着可以定义一个函数来获取任何 `IpAddrKind`：

```rust
fn route(ip_type: IpAddrKind) { }
```

现在可以使用任一成员来调用这个函数：

```rust
route(IpAddrKind::V4);
route(IpAddrKind::V6);
```



### 1.3 类C枚举

`Rust`还允许给枚举体的每个变体设置一个整形数值：

```rust
#[repr(u8)]
enum HttpStatus {
    Ok = 200,
    NotFound = 404,
}
```

此处定义了一个`Http`状态码的枚举，并且给不同状态设定了对于的数值。顶部的`#[repr(u8)]`用于指定变体的数据类型，此处指定为`u8`。

这种枚举本身在`Rust`中意义不大，因为`Rust`很少用到整形与枚举直接转换的性质。这个性质主要用于和`C语言`的接口进行交互，从而兼容C风格的枚举。



### 1.4 带参枚举

我们可以给枚举的成员定义类型

例如，ipv4和ipv6都是以字符串的形式展示的，可以这样定义

```rust
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
```

再比如，ipv4是由四个32位的数字组成的，可以进一步这样定义

```rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
```



除此之外，枚举的每个成员都可以限制各种类型

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

这个枚举有四个含有不同类型的成员：

- `Quit` 没有关联任何数据。
- `Move` 包含一个匿名结构体。
- `Write` 包含单独一个 `String`。
- `ChangeColor` 包含三个 `i32`。



### 1.5 枚举方法

和`struct`一样，枚举也可以通过`impl`块定义方法

```rust
impl Message {
    fn call(&self) {
        match self {
            Message::Write(text) => println!("Text message: {}", text),
            _ => println!("Other type of message"),
        }
    }
}

let m = Message::Write(String::from("hello"));
m.call();
```









## 2.match控制流

### 2.1 基本使用

 `match`是Rust中的极为强大的**控制流运算符**，它允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行相应代码。

模式可由字面值、变量、通配符和许多其他内容构成；

`match` 的力量来源于模式的表现力以及编译器检查，它确保了所有可能的情况都得到处理。

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

拆开 `value_in_cents` 函数中的 `match` 来看。首先，我们列出 `match` 关键字后跟一个表达式，在这个例子中是 `coin` 的值。这看起来非常像 `if` 使用的表达式，不过这里有一个非常大的区别：对于 `if`，表达式必须返回一个布尔值，而这里它可以是任何类型的。

接下来是 `match` 的分支。一个分支有两个部分：一个模式和一些代码。第一个分支的模式是值 `Coin::Penny` 而之后的 `=>` 运算符将模式和将要运行的代码分开。这里的代码就仅仅是值 `1`。每一个分支之间使用逗号分隔。

当 `match` 表达式执行时，它将结果值按顺序与每一个分支的模式相比较。如果模式匹配了这个值，这个模式相关联的代码将被执行。如果模式并不匹配这个值，将继续执行下一个分支，非常类似一个硬币分类器

**每个分支相关联的代码是一个表达式，而表达式的结果值将作为整个 `match` 表达式的返回值。**



如果分支代码较短的话通常不使用大括号，正如上面例子中的每个分支都只是返回一个值。如果想要在分支中运行多行代码，可以使用大括号。例如，如下代码在每次使用`Coin::Penny` 调用时都会打印出 “Lucky penny!”，同时仍然返回代码块最后的值，`1`：

```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        },
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```



### 2.2 绑定值的模式

匹配分支的另一个有用的功能是可以绑定匹配的模式的部分值。这也就是如何从枚举成员中提取值的。

作为一个例子，让我们修改枚举的一个成员来存放数据。1999 年到 2008 年间，美帝在 25 美分的硬币的一侧为 50 个州的每一个都印刷了不同的设计。其他的硬币都没有这种区分州的设计，所以只有这些 25 美分硬币有特殊的价值。可以将这些信息加入我们的 `enum`，通过改变 `Quarter` 成员来包含一个 `State` 值，示例 6-4 中完成了这些修改：

```rust
#[derive(Debug)] // 这样可以可以立刻看到州的名称
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
```

示例 6-4：`Quarter` 成员也存放了一个 `UsState` 值的 `Coin` 枚举

想象一下我们的一个朋友尝试收集所有 50 个州的 25 美分硬币。在根据硬币类型分类零钱的同时，也可以报告出每个 25 美分硬币所对应的州名称，这样如果我们的朋友没有的话，他可以将其加入收藏。

在这些代码的匹配表达式中，我们在匹配 `Coin::Quarter` 成员的分支的模式中增加了一个叫做 `state` 的变量。当匹配到 `Coin::Quarter` 时，变量 `state` 将会绑定 25 美分硬币所对应州的值。接着在那个分支的代码中使用 `state`，如下：

```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        },
    }
}
```

如果调用 `value_in_cents(Coin::Quarter(UsState::Alaska))`，`coin` 将是 `Coin::Quarter(UsState::Alaska)`。当将值与每个分支相比较时，没有分支会匹配，直到遇到 `Coin::Quarter(state)`。这时，`state` 绑定的将会是值 `UsState::Alaska`。接着就可以在 `println!` 表达式中使用这个绑定了，像这样就可以获取 `Coin` 枚举的 `Quarter` 成员中内部的州的值。





### 2.3 匹配 `Option`

我们在之前的部分中使用 `Option<T>` 时，是为了从 `Some` 中取出其内部的 `T` 值；我们还可以像处理 `Coin` 枚举那样使用 `match` 处理 `Option<T>`！与其直接比较硬币，我们将比较 `Option<T>` 的成员，不过 `match` 表达式的工作方式保持不变。

比如我们想要编写一个函数，它获取一个 `Option<i32>` 并且如果其中有一个值，将其加一。如果其中没有值，函数应该返回 `None` 值并不尝试执行任何操作。

得益于 `match`，编写这个函数非常简单，它将看起来像示例 6-5 中这样：

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```



让我们更仔细地检查 `plus_one` 的第一行操作。当调用 `plus_one(five)` 时，`plus_one` 函数体中的 `x` 将会是值 `Some(5)`。接着将其与每个分支比较。

```rust
None => None,
```

值 `Some(5)` 并不匹配模式 `None`，所以继续进行下一个分支。

```rust
Some(i) => Some(i + 1),
```

`Some(5)` 与 `Some(i)` 匹配吗？当然匹配！它们是相同的成员。`i` 绑定了 `Some` 中包含的值，所以 `i` 的值是 `5`。接着匹配分支的代码被执行，所以我们将 `i` 的值加一并返回一个含有值 `6` 的新 `Some`。

接着考虑下示例 6-5 中 `plus_one` 的第二个调用，这里 `x` 是 `None`。我们进入 `match` 并与第一个分支相比较。

```rust
None => None,
```

匹配上了！这里没有值来加一，所以程序结束并返回 `=>` 右侧的值 `None`，因为第一个分支就匹配到了，其他的分支将不再比较。

将 `match` 与枚举相结合在很多场景中都是有用的。你会在 Rust 代码中看到很多这样的模式：`match` 一个枚举，绑定其中的值到一个变量，接着根据其值执行代码。这在一开始有点复杂，不过一旦习惯了，你会希望所有语言都拥有它！这一直是用户的最爱。





### 2.4 匹配是穷尽的

`match` 还有另一方面需要讨论。考虑一下 `plus_one` 函数的这个版本，它有一个 bug 并不能编译：

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
    }
}
```

我们没有处理 `None` 的情况，所以这些代码会造成一个 bug。幸运的是，这是一个 Rust 知道如何处理的 bug。如果尝试编译这段代码，会得到这个错误：

```text
error[E0004]: non-exhaustive patterns: `None` not covered
 -->
  |
6 |         match x {
  |               ^ pattern `None` not covered
```

Rust 知道我们没有覆盖所有可能的情况甚至知道哪些模式被忘记了！Rust 中的匹配是 **穷尽的**（*exhaustive*）：必须穷举到最后的可能性来使代码有效。特别的在这个 `Option<T>` 的例子中，Rust 防止我们忘记明确的处理 `None` 的情况，这使我们免于假设拥有一个实际上为空的值，这造成了之前提到过的价值亿万的错误。





### 2.5 _ 通配符

Rust 也提供了一个模式用于不想列举出所有可能值的场景。例如，`u8` 可以拥有 0 到 255 的有效的值，如果我们只关心 1、3、5 和 7 这几个值，就并不想必须列出 0、2、4、6、8、9 一直到 255 的值。所幸我们不必这么做：可以使用特殊的模式 `_` 替代：

```rust
let some_u8_value = 0u8;
match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    _ => (),
}
```

`_` 模式会匹配所有的值。通过将其放置于其他分支之后，`_` 将会匹配所有之前没有指定的可能的值。`()` 就是 unit 值，所以 `_` 的情况什么也不会发生。因此，可以说我们想要对 `_` 通配符之前没有列出的所有可能的值不做任何处理。

然而，`match` 在只关心 **一个** 情况的场景中可能就有点啰嗦了。为此 Rust 提供了`if let`。





## 3.重要枚举

### 3.1 Option< T >

Rust中是没有null的，想要想其他语言一样使用null，在rust中需要使用Option

`Option<T>` 用来表达“一个值可能存在，也可能不存在”。定义如下：

```rust
enum Option<T> {
    Some(T),
    None,
}
```

此处的`<T>`表示一个[泛型](./15.泛型.md)，即它可以承载任意类型的参数。

它的第一个变体为`Some`，第二个变体为`None`，前者表示值存在，后者表示值不存在。

假设有一个`i32`，你如何表示一个数字不存在？有人说使用`0`来表示这个数字不存在，但是`0`也算一种取值。

这就是`Option`的作用，可以表示不存在这一种状态。

首先，`Option`可以代替其他语言中的`null`。

```rust
let maybe_number: Option<i32> = Some(5);
let absent: Option<i32> = None;
```

`Some`和`None`是**rust**中两个特殊的变体，可以单独使用，上面两行代码中的`Some`和`None`完全写法如下

```rust
let maybe_number: Option<i32> = Option::Some(5);
let absent: Option<i32> = Option::None;
```



在别的语言用 `null` 表示“没有值”，`Rust` 用 `None` 来表达。这消除了空指针的风险。

比如说你拿到一个 `Option<i32>` 后，可以使用`match`进行匹配：

```rust
let maybe_number: Option<i32> = Some(5);

match maybe_number {
    Some(number) => println!("number: {}", number),
    None => println!("number is disappear"),
}
```

由于`match`穷尽性的要求，`Rust`要求你必须处理`None`，从而减少不安全的行为。



#### 使用场景

当一个值可能有值，可能没值的时候，比如定义一个表单结构体，在填写调查表单时，有的人可能不方便填写姓名等信息，那么就可以这样

```rust
struct Survey{
    name: Option<String>,
    is_adult: Option<bool>,
    income: Option<f32>,
}
```



#### 常用方法

在前面，我们已经通过 `match` 模式匹配来使用 `Option`。不过，`Option` 自带一些非常实用的方法，可以让常见操作更简洁。

##### is_some() / is_none()

判断当前是否是 `Some` 或 `None`。

```rust
let x = Some(10);

assert!(x.is_some());   // x 确实是 Some
assert!(!x.is_none());  // 所以它不是 None
```

这两个方法常用于快速分支判断。

##### unwrap_or()

在有值时取出内容，否则给一个默认值。

```rust
let a = Some(5);
let b: Option<i32> = None;

let v1 = a.unwrap_or(0); // 得到 5
let v2 = b.unwrap_or(0); // 没有值，用默认 0
println!("v1={}, v2={}", v1, v2);
```



##### map()

对 `Some` 中的值做变换，如果是 `None` 就保持不变。

```rust
fn double(n: i32) -> i32 {
    n * 2
}

let y = Some(7);
let doubled = y.map(double); // Some(14)
println!("doubled={:?}", doubled);
```

此处的`y.map(double)`，意思是如果`y`里面是`Some`，那么把`Some`里面的`T`作为参数传给` double`，如果是`None`就啥也不干。



##### and_then()

常用于链式调用：

1. 如果是 `Some`，就把里面的`T`交给一个返回 `Option` 的函数处理
2. 如果是 `None`，就直接传递 `None`

```rust
fn to_even(n: i32) -> Option<i32> {
    if n % 2 == 0 {
        Some(n)
    } else {
        None
    }
}

let z = Some(10);
let res1 = z.and_then(to_even); // Some(10)，因为10是偶数
println!("res1={:?}", res1);

let z2 = Some(11);
let res2 = z2.and_then(to_even); // None，因为11不是偶数
println!("res2={:?}", res2);
```



### 3.2 Result< T, E >

`Result<T, E>` 用来表达一次运算**可能成功，也可能失败**。定义如下：

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

它有两个变体：

- `Ok(T)` 表示操作成功，携带一个结果值 `T`。
- `Err(E)` 表示操作失败，携带一个错误信息 `E`。

这种设计思想可以让错误处理显式、安全，而不是像某些语言那样抛异常（exception），读代码时一眼就能看出哪里会失败。

比如写一个除法函数，如果除数是 0，显然要报错：

```rust
fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err("除数不能为0".to_string())
    } else {
        Ok(a / b)
    }
}
```

调用的时候可以用 `match` 进行匹配：

```rust
match divide(10, 2) {
    Ok(v) => println!("结果是 {}", v),
    Err(e) => println!("错误: {}", e),
}
```

- 如果`divide(10, 2)`的返回值是`Ok()`变体，则携带的值就会赋值给v
- 如果`divide(10, 2)`的返回值是`Err()`变体，则携带的错误信息就会赋值给e

这就是最基本的 `Result` 使用方式。

#### 常用方法

和 `Option` 一样，`Result` 也内置了许多常见操作方法，让你不必总是写 `match`。

##### is_ok()

判断`Result`的结果是否成功，返回bool类型

```rust
let r1: Result<i32, &str> = Ok(42);


assert!(r1.is_ok());
```



##### is_err()

判断`Result`的结果是否失败，返回bool类型

```rust
let r2: Result<i32, &str> = Err("出错啦");

assert!(r2.is_err());
```





##### unwrap_or()

成功时取出值，失败时给一个默认值。

```rust
let r1: Result<i32, &str> = Ok(5);
let r2: Result<i32, &str> = Err("失败了");

let v1 = r1.unwrap_or(0); // 得到 5
let v2 = r2.unwrap_or(0); // 出错时取默认值 0

println!("v1={}, v2={}", v1, v2);
```



##### map()

如果是成功，就对里面的 `Ok(T)` 做变换；如果是错误，则保持 `Err(E)` 不变。

```rust
fn double(n: i32) -> i32 {
    n * 2
}

let r: Result<i32, &str> = Ok(7);
let doubled = r.map(double); // Ok(14)
println!("doubled={:?}", doubled);

let e: Result<i32, &str> = Err("错误");
let still_err = e.map(double); // Err("错误")
println!("still_err={:?}", still_err);
```



##### and_then()

常用于链式调用：

1. 如果是 `Ok(T)`，就把 `T` 传递给一个 **返回 `Result` 的函数** 继续处理。
2. 如果是 `Err(E)`，就直接返回 `Err`。

```rust
fn check_even(n: i32) -> Result<i32, String> {
    if n % 2 == 0 {
        Ok(n)
    } else {
        Err("不是偶数".to_string())
    }
}

let r1: Result<i32, &str> = Ok(10);
let res1 = r1.and_then(|n| check_even(n)); 
println!("res1={:?}", res1); // Ok(10)

let r2: Result<i32, &str> = Ok(11);
let res2 = r2.and_then(|n| check_even(n));
println!("res2={:?}", res2); // Err("不是偶数")
```



##### unwrap_or_else()

失败时通过一个函数来生成默认值，比 `unwrap_or` 更灵活。

```rust
fn default_value(err: &str) -> i32 {
    println!("出错: {}", err);
    -1
}

let r: Result<i32, &str> = Err("网络故障");
let v = r.unwrap_or_else(default_value); // 调用 default_value，得到 -1
println!("v={}", v);
```



## 4.?运算符

?运算符：是Rust 中用于错误处理的简洁语法，主要作用是从函数中提前返回错误

- 它可以用在返回 Result或Option 类型的函数中
  - 成功时：解包 `Ok(T)`或 `Some(T)`中的值，程序继续执行 
  - 失败时：提早返回 `Err(E)`或 `None`，错误值会自动转换（若可能）



当一个返回Result的函数中使用了另一个返回`Result`的函数，使用`?`运算符可以减少`match`语句的使用

```rust {9-12}
fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err("除数不能为0".to_string())
    } else {
        Ok(a / b)
    }
}

fn get_divide(a: i32, b: i32) -> Result<i32, String> {
    divide(a, b)?;
    Ok(a / b)
}

fn main() {
    let res = get_divide(500, 100);
    match res {
        Ok(d) => println!("{}", d),
        Err(s) => println!("{}", s),
    }
}
```



