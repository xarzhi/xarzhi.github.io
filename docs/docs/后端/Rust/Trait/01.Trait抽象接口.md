# Trait 抽象接口

Rust 强调将数据（结构体的字段）和行为（trait 定义的方法）分离。结构体负责存储数据，而 trait 负责定义操作这些数据的接口。这种设计使得代码更加清晰和模块化。

抽象接口是`Trait`的最基础的用法，它的特点如下：

1. 使用`trait`关键字定义接口
2. 接口中可以定义方法，并支持默认实现
3. 使用`impl`关键字为类型实现接口方法
4. 接口中不能实现另一个接口，但接口之间可以继承
5. 同一个接口可以被多个类型实现，但不能被一个类型实现多次



## 1.定义与实现

Trait定义了一组可以被共享的行为，只要实现了Trait，该**类型**就能使用这组行为。

### 1.1 定义Trait

定义trait基本语法如下，trait的名称应使用**大驼峰**

```rust
trait TraitName {
	fn func_1(args...) ->return_type ;     // 关联函数

	fn func_2(&self, args..) -> return_type ;		// 方法
}
```

使用`trait`关键字，可以定义一个`Trait`。在它的名字后面，使用`{}`定义这个`Trait`所具有的方法。

**在定义时，往往只写出函数的签名**，并且允许使用`Self`作为第一个参数，函数体用`;`代替，表示还未实现。

### 1.2 实现Trait

```rust
impl TraitName for type {
	fn func_1(args...) -> return_type {
		// ...
	}

	fn func_2(&self, args..) -> return_type {
		// ...
	}
}
```

使用`impl`关键字，可以为指定类型实现指定`Trait`，例如`impl Add for i32`就是给`i32`类型实现`Add`。

在`{}`中，**需要给每一个之前定义的方法做出实现**，必须实现所有未提供默认实现的方法。

假设现有两个结构体：

```rust
struct Person {
    name: String,
    age: u8,
    can_swim: bool,
}

struct Duck {
    color: String,
}
```

它们分别表示一个人，以及一只鸭子。`Person::can_swim`表示这个人是否学会游泳。

随后定义一个`Trait`，表示一个类型是否有游泳的能力：

```rust
trait Swim {
	fn swim(&self);
}
```

分别为`Duck`和`Person`实现这个`Swim`的特征：

```rust
impl Swim for Duck {
    fn swim(&self) {
        println!("I was born to swim.");
    }
}

impl Swim for Person {
    fn swim(&self) {
        if self.can_swim {
            println!("I've learned to swim.");
        } else {
            println!("I can't swim.");
        }
    }
}
```

对鸭子来说，天生就会游泳，而人类需要通过后天学习。

```rust
let p = Person {
    name: "zhangsan".to_string(),
    age: 28,
    can_swim: true,
};

let d = Duck {
    color: "yellow".to_string(),
};

p.swim();
d.swim();
```

最后，不论是`Person`还是`Duck`类型，都可以去调用`swim`这个方法，并且最后执行了不同的函数逻辑。



## 2.默认实现

`Trait` 可以提供默认实现，这样实现者可以直接使用，也可以选择覆盖。

```rust
trait Swim {
    fn swim(&self) {
        println!("I was born to swim.");
    }
}
```

在定义`Swim`这个`Trait`的时候，可以直接为其默认实现，后续实现该`Trait`的类型，可以选择不实现这个方法，从而使用默认实现。

比如此时`Duck`类型就可以直接使用默认实现：

```rust
impl Swim for Duck { }

impl Swim for Person {
    fn swim(&self) {
        if self.can_swim {
            println!("I've learned to swim.");
        } else {
            println!("I can't swim.");
        }
    }
}
```

在`impl Swim for Duck`的时候，没有实现任何方法，使用了默认实现。



## 3.泛型 Trait

在`Trait`中，支持使用泛型，语法如下：

```rust
trait TraitName<T, ...> {
}

impl<T, ...> TraitName<T, ...> for type {
}
```

只需要在名称后面添加泛型声明列表，后续在实现中就可以使用。

例如实现一个`MySwap`：

```rust
trait MySwap<RHS> {
    fn my_swap(self, other: RHS) -> (RHS, Self);
}

impl<RHS> MySwap<RHS> for i32 {
    fn my_swap(self, other: RHS) -> (RHS, Self) {
        (other, self)
    }
}
```

此处的`RHS`是一个泛型，表示右操作数`Right Hand Side`。与基本的泛型语法相同，在`impl`时需要先`impl<>`声明泛型，后续才能使用。

要注意的是：当模板参数不同，`MySwap`是不同的`Trait`，例如`MySwap<i32>`与`MySwap<i64>`是两个不同的`Trait`实现，这是通过单态化实现的。



## 4.关联类型

假设现在我们要实现一个`MyAdd`，它表示加法操作。

```rust
trait MyAdd<RHS, Output> {
    fn my_add(self, rhs: RHS) -> Output;
}
```

它涉及两个泛型参数，`RHS`表示右操作数，`Output`表示最终返回值。分开两个泛型参数是因为不同情况下所需的返回值可能不同，比如说 `i64 + i32`和`i32 + i64`最好返回`i64`，才能防止溢出。而前者`Self = i32`、`RHS = i64`，后者相反。你很难把这个返回值固定下来，以适配所有情况，所以把返回值单独做成了一个泛型。

实现这个`Trait`：

```rust
// i32 + i32
impl MyAdd<i32, i32> for i32 {
    fn my_add(self, other: i32) -> i32 {
        self + other
    }
}

// i32 + i64
impl MyAdd<i64, i64> for i32 {
    fn my_add(self, other: i64) -> i64 {
        self as i64 + other
    }
}

// i64 + i32
impl MyAdd<i32, i64> for i64 {
    fn my_add(self, other: i32) -> i64 {
        self + other as i64
    }
}
```

现在就可以正常调用了：

```rust
 let i3: i32 = 10;
 let i6: i64 = 10;

 let r1 = i3.my_add(i3);
 let r2 = i3.my_add(i6);
 let r3 = i6.my_add(i3);
```

现在看来一切正常，这个方案确实可以实现我们的目的，在不同情况下根据两个操作数决定加法返回类型。

但有一个问题是，两个类型相加，那么返回类型也应该是固定的，但这个实现方案，允许已知的两个操作数返回不定的类型。

例如：

```rust
// i32 + i32
impl MyAdd<i32, i32> for i32 {
    fn my_add(self, other: i32) -> i32 {
        self + other
    }
}

// i32 + i32
impl MyAdd<i32, i64> for i32 {
    fn my_add(self, other: i32) -> i64 {
        (self + other) as i64
    }
}
```

以上代码，把`i32 + i32`依据返回值不同，实现了两个返回版本，这就进一步导致两个确定类型的加法，允许返回一个不确定类型。

你可以利用返回值自动推导泛型参数，来调用不同版本：

```rust
let i3: i32 = 10;
let r4: i32 = i3.my_add(i3);
let r5: i64 = i3.my_add(i3);
```

以上代码中，`r4`调用的是返回`i32`的版本，而`r5`调用的是返回`i64`的版本。因为泛型是调用层来决定调用哪一个版本的。

我们希望的是，当`Self`、`RHS`已知，那么`Output`就是固定的，这才符合`Rust`对类型系统的安全性要求。也就是说我们希望`Self`和`RHS`是可变的，这两个固定则`Output`固定，但目前`Self`、`RHS`、`Output`都是可变的。

此时就需要引入`关联类型`。

关联类型允许为不同类型实现`Trait`时，分别指定一个类型进行关联。

- 在定义时，通过`type`关键字定义一个**关联类型**：

```rust
trait MyAdd<RHS> {
	type Output;
	fn my_add(self, rhs: RHS) -> Self::Output;
}
```

此处的`Output`就是一个关联类型，在定义时，关联类型相当于一个泛型，它的类型是不确定的。

- 在实现时，需要给关联类型指定一个具体的类型：

```rust
// i32 + i32
impl MyAdd<i32> for i32 {
    type Output = i32;
    fn my_add(self, other: i32) -> Self::Output {
        self + other
    }
}

// i32 + i64
impl MyAdd<i64> for i32 {
    type Output = i64;
    fn my_add(self, other: i64) -> Self::Output {
        self as i64 + other
    }
}

// i64 + i32
impl MyAdd<i32> for i64 {
    type Output = i64;
    fn my_add(self, other: i32) -> Self::Output {
        self + other as i64
    }
}
```

在`Self = i32`、`RHS = i32`时，则`Output = i32`，后两个同理。

这就是关联类型的作用：当`Trait`确定，实现该`Trait`的类型也确定，则关联类型是确定的。

要注意的是，前两个实现中，都是`i32`实现`MyAdd`，但是它们实现的不是同一个`Trait`，前者是`MyAdd<i32>`，后者是`MyAdd<i64>`，所以两者的`Output`允许不同。

可以通过下图来理解此处的逻辑：

![在这里插入图片描述](https://gitee.com/xarzhi/picture/raw/master/img/9ea00fe449fc45debb0d9693a8e7d30a.png)

左侧是`Output`作为泛型的版本，右侧是`Output`作为关联类型的版本。整个`Trait`分为三个步骤，定义，实现，调用。

在泛型中，泛型参数的取值是在调用时决定的(左侧绿色部分)，用户可以自由指定`RHS`和`Output`的类型，如果有匹配的实现，那么就调用成功。用户传入确定的`Self`和`RHS`，依然可以进一步自行决定`Output`。

而在关联类型中，关联类型的取值是在实现时决定的(右侧绿色部分)，那么用户传入确定的`Self`和`RHS`后，一定得到的是确定的`Output`。

两者的核心区别在于，确定这个`Output`类型的时机不同(绿色部分)，一个在用户调用时确定，另一个在实现时就已经确定了。

在实际应用中，如果你确实希望用户可以自行决定这个类型，那么将它作为泛型。如果你希望当`Self`和`Trait`已经确定时，某个类型也得到一个确定值，那就将它作为关联类型。

最后，在定义`Trait`时，可以设置关联类型的默认值：

```rust
trait MyAdd<RHS> {
	type Output = Self;
	fn my_add(self, rhs: RHS) -> Self::Output;
}
```

这个特性需要较`nightly`版本的`Rust`支持，截止`1.90.0`依然不稳定。



## 5.关联常量

除了关联类型，`Trait` 还可以定义关联常量，此处的关联常量和之前在`impl`时讲的关联常量是一样的。

```rust
trait Limit {
    const MAX: u32;
}

struct Counter;
impl Limit for Counter {
    const MAX: u32 = 100;
}
```

与关联类型同样的是，关联常量在定义`Trait`阶段定义，在实现阶段确定值。



关联常量可以给一个默认值，并且已经是一个稳定特性了，可以直接使用。

```rust
trait Limit {
    const MAX: u32 = 100;
}
```



## 6.Trait 继承

`Rust`不支持面向对象中的类型继承，但是在`Trait`之间允许继承。

语法：

```rust
trait TraitName: t1 + t2 ... {
}
```

定义`Trait`时，在名称后面使用`:`指明要继承的其它`Trait`，多个`Trait`之间使用`+`分隔。

此处继承的含义为：如果某个类型要实现该`Trait`，必须实现它继承的所有`Trait`。

示例：

```rust
use std::fmt::Display;

trait Introduce: Display {
    fn introduce(&self) {
        println!("我是：{}", self);
    }
}
```

此处的 `Introduce` 用于自我介绍，它要求类型必须实现`Display`这个类型，才能保证`print`的时候不报错。

```rust
struct Cat {
    name: String,
}

impl Display for Cat {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "猫咪 {}", self.name)
    }
}

impl Introduce for Cat {}

let my_cat = Cat { name: "咪咪".to_string() };
my_cat.introduce();
```

在这个`Cat`类中，首先实现`Display`，然后才能实现`Introduce`，并且使用了默认实现。最后`my_cat`这个实例就可以调用`introduce`方法。

其实此处的`Trait`继承与面向对象中的继承区别还是很大的，它更多的是表示一种接口之间的依赖关系，比如`introduce`依赖`Display`。



## 7.完全限定语法

一个类型的多个`Trait`是可以分别自由实现方法的，那么也就允许多个`Trait`中出现同名方法。而当多个 `Trait` 或者类型本身`impl`的方法名发生冲突时，编译器就会陷入困境。此时就需要 `完全限定语法 (Fully Qualified Syntax)`来避免歧义。

`Rust` 的方法调用有一个推导的过程：

- 编译器会先在当前类型的固有方法里查找，即`impl`的内容
- 如果没找到，再去该类型实现的所有 `Trait` 中查找
- 如果存在多个候选，就会报错，提示你需要显式指定

完全限定语法如下：

```rust
<Type as Trait>::method(args...)
```

`Type` 表示具体的类型，`Trait` 表示方法来源的`Trait`，`method` 是要调用的方法名，`args...` 是额外的参数。

假设我们有两个 `Trait`，它们都定义了一个同名方法：

```rust
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!("Pilot flying the plane!");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        println!("Wizard flying with magic!");
    }
}

impl Human {
    fn fly(&self) {
        println!("Human flapping arms... not very effective.");
    }
}
```

此时 `Human` 类型同时具备三种 `fly` 方法：

- 自身固有方法 `Human::fly`
- 来自 `Pilot` 的 `fly`
- 来自 `Wizard` 的 `fly`

如果直接调用：

```rust
let h = Human;
h.fly();
```

编译器会优先选择固有方法，因此输出：

```rust
Human flapping arms... not very effective.
```

但如果我们想调用 `Pilot` 或 `Wizard` 的版本，就必须使用完全限定语法：

```rust
Pilot::fly(&h);            // 等价于 <Human as Pilot>::fly(&h)
Wizard::fly(&h);           // 等价于 <Human as Wizard>::fly(&h)
<Human as Pilot>::fly(&h); // 更显式的写法
```

此处由于第一个参数是`self`，所以要传入`&h`作为参数。通过完全限定语法就能明确告诉编译器要调用的是哪个 `Trait` 的实现。



## 8.孤儿规则

基于`impl`和`trait`两个特性，你可以很轻易的给一个类型添加各种方法，这就有可能导致一些不太安全的操作。

比如你的某位同事，已经为一个类型封装好了它的各类接口和`Trait`。但是你使用这个类型前，又对它的这个`Trait`进行了实现，导致篡改了某些该类型原本的行为，这就是一种破坏性的改写，可能导致难以预料的Bug，孤儿规则可以避免类似的情况。

> 如果要实现某个`Trait`，那么该`Trait`和要实现这个`Trait`的类型，至少有一个要在当前`Crate`中定义

此处的`Crate`可以理解为一个库，比如`std`标准库算一个`Crate`，这个内容会在后续深入讲解。

- 尝试给`Vec<i32>`实现`std::fmt::Display`：

`Vec<i32>`是标准库中的一个动态数组类型，而`std::fmt::Display`是一个标准库的`Trait`，实现后可以被`print`输出。

```rust
impl std::fmt::Display for Vec<i32> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "My custom Vec: {:?}", self)
    }
}
```

以上代码尝试给`Vec<i32>`实现`std::fmt::Display`，但是这个代码会报错，因为`Vec<i32>`这个类型不属于本地，而`std::fmt::Display`也不属于本地，这违背了孤儿规则，编译不通过。

- 给标准库类型实现本地`Trait`

```rust
trait MyTrait {
    fn my_method(&self);
}

impl MyTrait for Vec<i32> {
    fn my_method(&self) {
        println!("Vec length: {}", self.len());
    }
}
```

以上代码给`Vec<i32>`实现`MyTrait`，这个代码是合法的，因为`MyTrait`是本地的，符合孤儿规则。

- 给本地类型实现标准库`Trait`

```rust
struct MyStruct;

impl std::fmt::Display for MyStruct {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "This is MyStruct")
    }
}

let my_instance = MyStruct;
println!("{}", my_instance);
```

此处的 `MyStruct` 是自己定义的类型，`std::fmt::Display`是之前提到的标准库`Trait`。实现这个`Trait`后，直接就可以通过`print`输出结构体。以上过程也是正确的，因为类型是本地的，符合孤儿规则。



## 9.NewType 模式

在介绍孤儿规则时我们提到：**你不能为外部类型实现外部 trait**。这条规则保证了编译器在全局范围内的一致性，但在工程实践中也经常让人卡壳。比如：

- 你想为 `String` 实现某个第三方库的 `trait`
- 或者你想为 `Vec<T>` 增加一个外部 trait 的实现

那么该怎么办？`Rust` 社区的惯用解法就是 `Newtype` 模式。

所谓 `Newtype`，就是用一个新的元组结构体把原有类型“包裹”起来：

```rust
struct MyString(String);
```

这样一来，`MyString` 是你自己定义的本地类型，本地类型自然可以实现任何外部 `trait`。

假设我们想为 `String` 实现一个外部库的 `Display`：

```rust
use std::fmt::{self, Display, Formatter};

struct MyString(String);

impl Display for MyString {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "MyString says: {}", self.0)
    }
}

fn main() {
    let s = MyString("hello".to_string());
    println!("{}", s);
}
```

输出：

```rust
MyString says: hello
```

这里的关键点在于：`String` 是外部类型，而`Display` 是外部 `trait`。直接 `impl Display for String` 会违反孤儿规则，但 `MyString` 是我们自己定义的本地类型，所以 `impl Display for MyString` 完全合法。