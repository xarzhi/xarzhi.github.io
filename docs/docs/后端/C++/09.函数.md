# 函数

## 1.概念

函数是一段有名字的代码块，完成特定功能的代码块，可以被调用执行多次，实现复用。

在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：



## 2.基本语法

### 2.1 定义函数

```c++
返回类型 函数名(参数类型 参数名){
    函数体
}
```

- **返回类型**：一个函数可以返回一个值。有些函数执行所需的操作而不返回值，在这种情况下，返回类型是关键字 **void**。
- **函数名称**：这是函数的实际名称。函数名和参数列表一起构成了函数签名。
- **参数**：参数就像是占位符。**定义函数时，每一个参数都必须有类型声明**
  - 封装函数时，我们称之为**形参**，也就是形式上的参数，它并没有实际的值，**可以有多个形参**，多个形参用`,`隔开
  - 当函数被调用时，可以向参数传递一个值，这个值被称为**实参**。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
- **函数主体**：函数主体包含一组定义函数执行任务的语句。



**注意**：**函数的参数是可以修改的**，若不想函数的参数被修改，需要加上`const`

```c++
返回值类型 函数名(const 参数类型 参数名){
    函数体
}
```







### 2.2 使用函数

当封装好函数后，它是不会自己执行的，想让它执行，我们需要调用函数

我们可以在任何地方使用我们封装的函数，并可以有选择的传递参数，这时的参数名为**实参**，是有明确的值的

```c++
函数名(参数);
```



### 2.3 例子

```c++
#include <iostream>
using namespace std;


void print(string str) {
	cout << str << endl;
}
void add(int num1, int num2) {
	cout << num1 + num2 << endl;
}
int main(){
	print("你好");  // "你好"
	add(11, 22);	// 33
	return 0;
}

```



## 3.函数声明

在程序运行时，若遇到了函数调用，则会**在代码的上方寻找函数的定义**，若没有找到，则会出现问题

但我们有时候并不想把函数定义在上面，于是我们可以使用**函数声明**

![image-20240710152307243](https://gitee.com/xarzhi/picture/raw/master/img/image-20240710152307243.png)



### 3.1 作用

函数声明会**告诉编译器函数名称及如何调用函数**。函数的实际主体可以单独定义。

### 3.2 语法

函数声明包括以下几个部分：

```c++
返回值类型 函数名(参数类型 参数名);
```

例如

```c++
#include <iostream>
using namespace std;

int print_max(int num1, int num2);			// 函数声明

int main() {
	cout << max(100, 200);   // 200
	return 0;
}

int print_max(int num1, int num2) {
	return num1 > num2 ? num1 : num2;
}
```

在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：

```c++
int max(int, int);
```



函数声明使得我们不仅可以在任何地方定义函数，还**可以调用别的源文件的函数**

当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该**在调用函数的文件顶部声明函数**。

在实际项目开发中，会有众多的函数声明，这样我们总不可能在每个源文件中一个一个使用函数声明，于是我们可以使用**头文件**



## 4.头文件

### 4.1 概念

头文件是扩展名为 **.h** 的文件，与源文件（.cpp）一样，头文件中也是C++的源代码，头文件中包含了 C++中**函数**、**类**、**对象**等的声明和**宏定义**，它可以被多个源文件通过**#include**引用共享。



### 4.2 作用

C++中有“单一定义”规则，即一个对象只能被定义一次，**如果在一个源文件中定义了一个函数，其他的源文件想要使用这个函数就需要在使用前声明一下这个函数**，在编译结束之后，编译器链接的时候再去查找这些函数的定义。

当我们面临一个大的项目时，函数、变量非常的多。如果每个函数都在每个源文件中声明。那就太麻烦

所以，为了达到在不同的源文件中声明的一致性，为了省去这些繁琐又重复的过程，我们可以把这些对象的声明都放在少数几个文件中，需要用到这些声明的时候再到这些文件中查找，这样的文件，就是**头文件**。



### 4.3 定义

我们需要在vs右侧的解决方案资源管理器中，**右键头文件**=>**添加**=>**新建项**

![image-20240710150006201](https://gitee.com/xarzhi/picture/raw/master/img/image-20240710150006201.png)

创建一个后缀为`.h`的文件

![image-20240710150206076](https://gitee.com/xarzhi/picture/raw/master/img/image-20240710150206076.png)

一般来说，头文件的名称要和需要导入头文件的源文件名称一致

在此项目中，有一个`utils.cpp`文件，需要在`test.cpp`中使用这两个函数

![image-20240710150542640](https://gitee.com/xarzhi/picture/raw/master/img/image-20240710150542640.png)

我们在test.h中声明这两个函数

![image-20240710150737414](https://gitee.com/xarzhi/picture/raw/master/img/image-20240710150737414.png)



### 4.4 使用

按照来源的不同，有两种类型的头文件：**自己写的头文件**和**标准库**（编译器或者其他库的头文件）。

- 应用标准库的头文件使用`<>`语法：`#include <标准库>`
- 应用标准库的头文件使用`""`语法：`#include "头文件"`

在`test.cpp`中引入`test.h`，并使用里面的函数

![image-20240710151244332](https://gitee.com/xarzhi/picture/raw/master/img/image-20240710151244332.png)



## 5.函数的执行顺序

函数的执行是被压进**栈**中去执行的，栈就像是一个坑，**先进后出，后进先出**，若有函数先进入了这个坑，而其他函数在后面也进入了这个坑，那么第一个函数只能等待上面的函数出去后，自己才能出去。

我们的程序都是以`main`函数为入口，先执行`main`函数，在`main`函数中会调用其他的函数

`main`函数最先执行，最后执行完毕，而`main`函数中的其他函数，都是较`main`函数后执行，却比`main`函数先执行完毕

![image-20240708220245717](https://gitee.com/xarzhi/picture/raw/master/img/image-20240708220245717.png)



## 6.函数的返回值

### 6.1 语法

使用`return`关键字来执行函数的返回值

- **return语句执行后，函数后面的代码将不会执行**
- **return的值的类型必须要和函数名前面的返回值类型相同**，没有返回值，返回值类型就写`void`
- 调用函数时，可以通过`=`将函数的返回值赋值给别的变量，但注意变量的类型要和函数的返回值类型相同

```c++
返回值类型 函数名(){
    return 返回值;
}
```



### 6.2 例子

```c++
#include <iostream>
using namespace std;

int add(int num1, int num2) {
	return num1 + num2;
}
int main(){
	int res = add(11, 22);
	cout << res << endl;		// 33
	return 0;
}
```



## 7.函数的默认值

我们可以在定义函数的时候，给形参一个默认值

- **当调用此函数时，这个参数可传可不传**，**若给了这个参数值，则使用给的值，否则使用默认值**
- **不允许在有默认值的参数之后，在出现没有默认值的参数**

```c++
int add(int num,int num2=10){
    // 函数体
}
```



## 8.函数的重载

当**函数名相同，参数类型以及数量不同**时，就是函数重载

```c++
#include <iostream>
using namespace std;

void add() {
	cout << "啥也没有" << endl;
}
int add(int num1, int num2) {
	cout << "整数相加" << endl;
	return num1 + num2;
}
int add(float num1, float num2) {
	cout << "单浮点相加" << endl;
	return num1 + num2;
}
int add(double num1, double num2) {
	cout << "双浮点相加" << endl;
	return num1 + num2;
}
int main(){
	add();
	int res1 = add(11, 22);
	int res2 = add(1.1, 2.2);
	int res3 = add(1.11, 2.22);
	return 0;
}
```





## 9.函数的递归

函数的递归，也就是**函数调用自身**，使用递归需谨慎，要设置好有效的出口条件，不然无线递归容易造成栈溢出

计算阶乘：

```c++
#include <iostream>
using namespace std;

int factorial(int num) {
	if (num == 1) return 1;
	return num * factorial(num - 1);
int main(){
	cout << factorial(10) << endl;	// 3628800
	cout << factorial(5) << endl;	// 120
	cout << factorial(3) << endl;	// 6
	return 0;
}
```































