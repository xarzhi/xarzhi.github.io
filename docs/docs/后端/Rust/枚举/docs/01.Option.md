# Option

标准库std中有一个`mod`：`option` ，`Option`是属于`option`中的一个特殊枚举

类型 Option 表示一个可选值：每个 Option 均为 Some 并包含一个值，或者为 None，但不包含。 Option 类型在 Rust 代码中非常常见，因为它们有多种用途：

- 初始值
- 未在整个输入范围内定义的函数的返回值 (部分函数)
- 返回值，用于报告否则将报告简单错误的错误，其中错误返回 [`None`](https://www.rustwiki.org.cn/zh-CN/std/option/enum.Option.html#variant.None)
- 可选的结构体字段
- 可借用或 “taken” 的结构体字段
- 可选的函数参数
- 可空指针
- 从困难的情况中交换东西

:::tip

`Option<T>`是一个特殊的枚举，用来处理**空值**

在其他的语言中，往往都会有一个`null`关键字，用来表明当前变量的值为空，但在rust中需要使用`Option<T>`来表示空值

`Option<T>`在标准库的位置为` std::option::Option`，但是`Option<T>`在使用时不需要手动导入，`rust`已经自动导入了

:::

## 1.基本使用

`Option` 枚举包含两个成员，一个成员表示含有值：`Some(T)`, 另一个表示没有值：`None`，定义如下：

```rust
pub enum Option<T> {
    Some(T),
    None,
}
```

- 其中 `T` 是泛型参数，`Some(T)`表示该枚举成员的数据类型是 `T`，换句话说，`Some` 可以包含**任何类型**的数据



:::tip

`Option<T>` 枚举是如此有用以至于它被包含在了 [`prelude`](https://course.rs/appendix/prelude.html)（**prelude 属于 Rust 标准库，Rust 会将最常用的类型、函数等提前引入其中，省得我们再手动引入**）之中，你不需要将其显式引入作用域。

另外，它的成员 `Some` 和 `None` 也是如此，无需使用 `Option::` 前缀就可直接使用 `Some` 和 `None`。

比如下面一段代码

```rust
let maybe_number: Option<i32> = Option::Some(5);
let absent: Option<i32> = Option::None;
```

完全可以去掉`Option::`，然后使用下面的方式

```rust
let maybe_number: Option<i32> = Some(5);
let absent: Option<i32> = None;
```

:::



当使用`Some(T)`时，因为`Some`肯定是有值的，所以即使不显示声明类型，rust也会自动推导`T`的类型

如果使用 `None` 而不是 `Some`，需要告诉 Rust `Option<T>` 是什么类型的，因为编译器只通过 `None` 值无法推断出 `Some` 成员保存的值的类型。

```rust
let some_number = Some(5);
let some_string = Some("a string");

let absent_number: Option<i32> = None;
```



 

`Some(T)`和`T`并不是一样的，两种类型不能混为一谈，比如下面这段代码

```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
```

由于类型不同，所以不能相加，从而会报错







## 2.模式匹配

`Option<T>`既然是个枚举，那么就可以使用`match`进行模式匹配

```rust
let num = Some(66);
match num {
    Some(value) => println!("{}", value),
    None => (),
}
```

当匹配到`Some`时，被匹配的变量的值就会赋值给`Some()`的参数，在`Some`后的`{}`块中就可以使用这个变量的值



### 2.1 作为函数返回值

`Option<T>`通常作为函数的返回值

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

fn main() {
    let five = Some(5);
    let six: Option<i32> = plus_one(five);
    let none = plus_one(None);

    println!("{:?}", six);          // Some(6)
    println!("{:?}", none);         // None

}
```



### 2.2 给外面变量赋值

`Some(T)`毕竟不能跟别的类型一块运算，但是可以通过`match`修改外部变量的值，从而进一步运算

```rust
let age = Some(19);

let is_adult = match age {
    Some(value) => {
        if value>=18 {true} else{false}
    }
    None => false,
};

println!("{}", is_adult); // true
```

想取出`Some(T)`的值，也可以使用`Option<T>`的`unwrap()`方法，后面会有介绍



### 2.3 if let



## 3.方法

以下是`Option<T>`中的方法



### is_some

判断调用对象是否为`Some`，返回布尔值

```rust
pub const fn is_some(&self) -> bool
```

**返回值**：根据调用对象是否为`Some`，返回`bool`

```rust
let x: Option<u32> = Some(2);
println!("{}", x.is_some());		// true

let x: Option<u32> = None;
println!("{}", x.is_some());		// false
```

**源码**：

```rust
#[must_use = "if you intended to assert that this has a value, consider `.unwrap()` instead"]
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
#[rustc_const_stable(feature = "const_option_basics", since = "1.48.0")]
pub const fn is_some(&self) -> bool {
    matches!(*self, Some(_))
}
```



### is_some_and

判断调用对象是否为`Some`

- 如果调用对象为`Some`，则把`Some`里的值赋值给闭包函数的参数，最后返回闭包函数的返回值
- 如果调用对象为`None`，闭包不会执行,则直接返回`false`

```rust
pub fn is_some_and(self, f: impl FnOnce(T) -> bool) -> bool
```

**参数**：

- f：闭包函数，当调用对象为`Some`时，会把`Some(T)`中`T`的值给`FnOnce(T)`的`T`

**返回值**：`bool`

- 若调用对象为`Some`，则返回闭包函数的返回值
- 若调用对象为`None`，则返回`false`

**源码**：

```rust
#[must_use]
#[inline]
#[stable(feature = "is_some_and", since = "1.70.0")]
pub fn is_some_and(self, f: impl FnOnce(T) -> bool) -> bool {
    match self {
        None => false,
        Some(x) => f(x),
    }
}
```



### is_none

判断调用对象是否为`None`

```rust
pub const fn is_none(&self) -> bool
```

**返回值**：根据调用对象是否为`None`，返回`bool`值

**源码**：

```rust
#[must_use = "if you intended to assert that this doesn't have a value, consider \
    `.and_then(|_| panic!(\"`Option` had a value when expected `None`\"))` instead"]
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
#[rustc_const_stable(feature = "const_option_basics", since = "1.48.0")]
pub const fn is_none(&self) -> bool {
    !self.is_some()
}
```



### as_ref

用于类型转换的方法，从 `&Option<T>` 转换为 `Option<&T>`。它的核心作用是在**不转移所有权**的前提下，将一个值转换为其引用形式。

```rust
pub const fn as_ref(&self) -> Option<&T>
```

**返回值**：返回一个不可变借用`Option<&T>`

```rust
let maybe_number: Option<String> = Some(String::from("42"));

if let Some(num_str_ref) = maybe_number.as_ref() {
    println!("值是: {}", num_str_ref);
    if let Ok(num) = num_str_ref.parse::<i32>() {
        println!("解析出的数字是: {}", num);
    }
}

// 因为使用了 as_ref()，maybe_number 在这里仍然有效
println!("原始的 Option: {:?}", maybe_number);
```

**源码**：

```rust
#[inline]
#[rustc_const_stable(feature = "const_option_basics", since = "1.48.0")]
#[stable(feature = "rust1", since = "1.0.0")]
pub const fn as_ref(&self) -> Option<&T> {
    match *self {
        Some(ref x) => Some(x),
        None => None,
    }
}
```





### as_mut



```rust

```

参数：

返回值：

源码：

```rust

```



### as_pin_ref



```rust

```

参数：

返回值：

源码：

```rust

```



### as_pin_mut



```rust

```

参数：

返回值：

源码：

```rust

```



### as_slice



```rust

```

参数：

返回值：

源码：

```rust

```



### as_mut_slice



```rust

```

参数：

返回值：

源码：

```rust

```



### expect



```rust

```

参数：

返回值：

源码：

```rust

```



### unwrap

从 `Some(value)`中提取出 `value`。如果遇到 `None`或 `Err(error)`，则触发 `panic!`导致程序终止。

```rust
pub fn unwrap(self) -> T
```

返回值：

- 若调用对象为 `Some(value)`，则返回 `value`
- 若调用对象为 `None`，则触发 `panic!`

```rust
let some_value: Option<i32> = Some(42);
let v = some_value.unwrap();
println!("{}", v); // 42

let none_value: Option<i32> = None;
let v = none_value.unwrap(); // 程序在此 panic！
```

:::tip

潜在的运行时恐慌（panic），导致程序意外终止，不适合在生产代码中随意使用。

:::

源码：

```rust
#[inline]
#[track_caller]
#[stable(feature = "rust1", since = "1.0.0")]
#[rustc_const_unstable(feature = "const_option", issue = "67441")]
pub const fn unwrap(self) -> T {
    match self {
        Some(val) => val,
        None => panic("called `Option::unwrap()` on a `None` value"),
    }
}
```



### unwrap_or

安全地提取 `Some(T)`中的值；遇到 `None`或 `Err(E)`时，返回一个指定的默认值。

```rust
pub fn unwrap_or(self, default: T) -> T
```

参数：

- **default**：当`self`为`None`时，需要返回的默认值

返回值：

- 若`self`为`Some`，则取出`Some`中的值并返回
- 若`self`为`None`，则返回传入的默认值

注意默认值的类型要和`Option<T>`的类型一致

源码：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn unwrap_or(self, default: T) -> T {
    match self {
        Some(x) => x,
        None => default,
    }
}
```



### unwrap_or_else

如果`self`是`Some`的话，则取出`Some`的值，否则返回回调的返回值

```rust
pub fn unwrap_or_else<F>(self, f: F) -> T
where
    F: FnOnce() -> T,
```

**参数**：

- f：闭包回调，当self为None时，才会调用此函数

**返回值**：

- 若`self`为`Some`，则取出`Some`中的值并返回
- 若`self`为`None`，则返回`f`的返回值

```rust
let some_value: Option<i32> = Some(42);
let res = some_value.unwrap_or_else(|| 666);
println!("{}", res);        // 42

let some_value: Option<i32> = None;
let res = some_value.unwrap_or_else(|| 666);
println!("{}", res);        // 666
```

**源码**：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn unwrap_or_else<F>(self, f: F) -> T
where
	F: FnOnce() -> T,
{
    match self {
        Some(x) => x,
        None => f(),
    }
}
```



### unwrap_or_default

如果self为Some，则取出Some的值并返回，否则返回`Option<T>`中T类型的默认值

比如：整数类型的默认值都是0，布尔的默认值是false

```rust
pub fn unwrap_or_default(self) -> T
where
    T: Default,
```

**返回值**：

- `self`为`Some`时，返回`Some`包含的值
- `self`为`None`时，返回`Option<T>`中T**类型的默认值**

```rust
let some_value: Option<i32> = Some(42);
let res: i32 = some_value.unwrap_or_default();
println!("{}", res); // 42

let some_value: Option<bool> = None;
let res = some_value.unwrap_or_default();
println!("{}", res); // false
```

**源码**：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn unwrap_or_default(self) -> T
where
	T: Default,
{
    match self {
        Some(x) => x,
        None => T::default(),
    }
}
```



### unwrap_unchecked

在不检查self是否为None的情况下，直接取出Some中的值，如果self为None，则会报错

使用`unwrap_unchecked`需要包含在`unsafe`块中

```rust
pub unsafe fn unwrap_unchecked(self) -> T
```

**返回值**：

- 如果self为Some，则取出Some的值
- 如果self为None，则会报错

```rust
let x = Some("hello");
let value = unsafe { x.unwrap_unchecked() };
println!("{}", value); // hello

let x: Option<&str> = None;
assert_eq!(unsafe { x.unwrap_unchecked() }, "air"); // 报错：未定义的行为！
```

**源码**：

```rust
#[inline]
#[track_caller]
#[stable(feature = "option_result_unwrap_unchecked", since = "1.58.0")]
#[rustc_const_unstable(feature = "const_option_ext", issue = "91930")]
pub const unsafe fn unwrap_unchecked(self) -> T {
    debug_assert!(self.is_some());
    match self {
        Some(val) => val,
        // SAFETY: 调用者必须坚持安全保证。
        None => unsafe { hint::unreachable_unchecked() },
    }
}
```



### map

将`Some`中的值取出，可以对之进行操作，最后再包装为`Some`返回

```rust
pub fn map<U, F>(self, f: F) -> Option<U>
where
    F: FnOnce(T) -> U,
```

**参数**：

- **f**：闭包函数
  - 若`self`为`Some`，则把`Some`所包含的值赋值给`f`的参数，可以在闭包函数中对其值进行操作后再返回，最终的返回结果依然是一个`Some`
  - 若`self`为`None`，则`map`直接返回`None`，不会调用`f`函数

**返回值**：

- 若`self`为`Some`，则返回处理后的`Some`
- 若`self`为`None`，则返回`None`

```rust
let some_value = Some(100);

let res = some_value.map(|x| {
    println!("{}", x);		// 100
    x * 2
});
println!("{:?}", res)		// Some(200)
```

**源码**：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn map<U, F>(self, f: F) -> Option<U>
where
	F: FnOnce(T) -> U,
{
    match self {
        Some(x) => Some(f(x)),
        None => None,
    }
}
```



### map_or

当`self`为`None`时直接返回默认值，否则可在闭包函数f中将`Some`中的值处理并返回

```rust
pub fn map_or<U, F>(self, default: U, f: F) -> U
where
    F: FnOnce(T) -> U,
```

**参数**：

- **default**：当`self`为`None`时，`map_or`函数返回的默认值
- **f**：当`self`为`Some`时，`Some`中包含的值会被赋值给f的参数，最后`map_or`函数将会返回`f`的返回值

**返回值**：

- 若`self`为`None`，返回参数`default`的值
- 若`self`为`Some`时，返回参数`f`的返回值

```rust
// 当self为Some时
let some_value: Option<i32> = Some(100);
let res = some_value.map_or(160, |x| {
    println!("{}", x);			// 100
    x * 2
});
println!("{:?}", res)			// 200


// 当self为None时
let some_value: Option<i32> = None;
let res = some_value.map_or(160, |x| {
    println!("{}", x);	
    x * 2
});
println!("{:?}", res)		// 160
```

**源码**：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn map_or<U, F>(self, default: U, f: F) -> U
where
	F: FnOnce(T) -> U,
{
    match self {
        Some(t) => f(t),
        None => default,
    }
}
```



### map_or_else

当`self`为`None`时返回`default`函数的返回值，否则可在闭包函数`f`中将`Some`中的值处理并返回

```rust
pub fn map_or_else<U, D, F>(self, default: D, f: F) -> U
where
    D: FnOnce() -> U,
    F: FnOnce(T) -> U,
```

参数：

- **default**：当self为None时，map_or会返回default函数的返回值
- **f**：当`self`为`Some`时，`Some`中包含的值会被赋值给f的参数，最后`map_or`函数将会返回`f`的返回值

返回值：

```rust
// 当self为Some时
let some_value: Option<i32> = Some(100);
let res = some_value.map_or_else(
    || 300,
    |x| {
        println!("{}", x);      // 100
        x * 2
    },
);
println!("{:?}", res)           // 200


// 当self为None时
let some_value: Option<i32> = None;
let res = some_value.map_or_else(
    || 300,
    |x| {
        println!("{}", x);      // 100
        x * 2
    },
);
println!("{:?}", res)           // 300
```

源码：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn map_or_else<U, D, F>(self, default: D, f: F) -> U
where
	D: FnOnce() -> U,
	F: FnOnce(T) -> U,
{
    match self {
        Some(t) => f(t),
        None => default(),
    }
}
```



### ok_or

把`Option`转化为`Result`返回

```rust
pub fn ok_or<E>(self, err: E) -> Result<T, E>
```

参数：

- **err**：被转化为`Result`后，若`Result`返回为`Err`，给`Err`的参数

返回值：

- 若`self`为`None`，则返回`Result`的`Err`变体，并把**参数`err`**传递给`Result`的`Err()`变体
- 若`self`为`Some`，则返回`Result`的`Ok`变体，并把`Some`包含的值传递给`Result`的`Ok()`变体

```rust
// 当self为Some时
let some_value: Option<String> = Some("这是成功的结果".to_string());
let res = some_value.ok_or("失败了");
println!("{:?}", res) // Ok("这是成功的结果")


// 当self为None时
let some_value: Option<String> = None;
let res = some_value.ok_or("失败了");
println!("{:?}", res) // Err("失败了")
```

源码：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn ok_or<E>(self, err: E) -> Result<T, E> {
    match self {
        Some(v) => Ok(v),
        None => Err(err),
    }
}
```



### ok_or_else

把`Option`转化为`Result`返回

```rust
pub fn ok_or_else<E, F>(self, err: F) -> Result<T, E>
where
    F: FnOnce() -> E,
```

参数：

- **err**：一个闭包函数，当`self`为`None`时，`ok_or_else`函数会把`err`函数的返回值传递给`Result`的`Err`变体

返回值：

- 若`self`为`None`，则返回`Result`的`Err`变体，并把**`err`函数的返回值**传递给`Result`的`Err()`变体
- 若`self`为`Some`，则返回`Result`的`Ok`变体，并把`Some`包含的值传递给`Result`的`Ok()`变体

```rust
// 当self为Some时
let some_value: Option<String> = Some("成功啦".to_string());
let res = some_value.ok_or_else(||"失败了");
println!("{:?}", res) // Ok("成功啦")

// 当self为None时
let some_value: Option<String> = None;
let res = some_value.ok_or_else(||"失败了");
println!("{:?}", res) // Err("失败了")
```

源码：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn ok_or_else<E, F>(self, err: F) -> Result<T, E>
where
	F: FnOnce() -> E,
{
    match self {
        Some(v) => Ok(v),
        None => Err(err()),
    }
}
```



### inspect

nspect方法接受一个闭包作为参数。

- 当 `Option`是 `Some(value)`时，这个闭包会以不可变引用（&T）的方式接收到内部值 value，你可以查看或打印它，但**无法修改**。之后，inspect会原封不动地将原始的 `Option<T>`传递给链中的下一个操作。
- 如果 Option是 None，则闭包不会执行，None会直接继续传递。

```rust
pub fn inspect<F>(self, f: F) -> Option<T>
where
	F: FnOnce(&T),
```

参数：

- **f**：一个闭包函数，返回`Some(T)`中`T`的借用

返回值：

- 当`self`为`None`时，则返回`None`
- 当`self`为`Some`时，返回`Some(T)`中`T`的借用

```rust
let number = Some(5);

let final_result = number
.inspect(|x| println!("初始值: {}", x)) // 查看初始值
.map(|x| x * 3)                         // 将值乘以3
.inspect(|x| println!("乘以3后: {}", x)) // 查看map之后的值
.filter(|x| x > &10)                   // 过滤，只保留大于10的值
.inspect(|x| println!("过滤后保留的值: {}", x)); // 查看过滤后的结果

println!("最终结果: {:?}", final_result); // 输出: Some(15)
```

源码：

```rust
#[inline]
#[unstable(feature = "result_option_inspect", issue = "91345")]
pub fn inspect<F>(self, f: F) -> Self
where
	F: FnOnce(&T),
{
    if let Some(ref x) = self {
        f(x);
    }

    self
}
```



### as_deref



```rust

```

参数：

返回值：

源码：

```rust

```



### as_deraf_mut



```rust

```

参数：

返回值：

源码：

```rust

```



### iter



```rust

```

参数：

返回值：

源码：

```rust

```



### iter_mut



```rust

```

参数：

返回值：

源码：

```rust

```



### and

接收一个`Option`参数，把自身和参数进行**逻辑与**，也就是`&&`

- 如果自身为`None`，则返回`None`，不会进行后面的判断
- 如果自身不为`None`，则返回参数的值

```rust
pub fn and<U>(self, optb: Option<U>) -> Option<U>
```

参数：

- optb：需要进行逻辑与运算的`Option`

返回值：如果`self`为 `None`，则返回`None`; 否则，返回 参数`optb`。

```rust
// 自身不为None，参数为None
let x = Some(2);
let y: Option<&str> = None;
println!("{:?}", x.and(y));         // None

// 自身不为None，参数不为None
let x: Option<u32> = Some(2);
let y = Some("foo");
println!("{:?}", x.and(y));         // Some("foo")

// 自身为None，参数不为None
let x: Option<u32> = None;
let y = Some("foo");
println!("{:?}", x.and(y));         // None

// 自身为None，参数为None
let x: Option<u32> = None;
let y: Option<&str> = None;
println!("{:?}", x.and(y));         // None
```

源码：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn and<U>(self, optb: Option<U>) -> Option<U> {
    match self {
        Some(_) => optb,
        None => None,
    }
}

```



### and_then

接受一个返回`Option`类型的闭包（函数）

- 如果自身为`None`，则返回`None`，不会进行后面的判断
- 如果自身不为`None`，则把自身`Some(T)`中`T`的值作为`f`的参数，最后返回`f`的返回值

```rust
pub fn and_then<U, F>(self, f: F) -> Option<U>
where
    F: FnOnce(T) -> Option<U>,
```

参数：

- f：一个返回`Option`的闭包函数

返回值：

- 如果自身为`None`，则返回`None`
- 如果自身不为`None`，则返回`f`的返回值

```rust
let num: Option<i32>=Some(3);

let result = num.and_then(|x| {
    println!("x的值为：{:?}", x);   // x的值为：3
    Some(x * 2)
});

println!("{:?}", result) // Some(6)
```

源码：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn and_then<U, F>(self, f: F) -> Option<U>
where
F: FnOnce(T) -> Option<U>,
{
    match self {
        Some(x) => f(x),
        None => None,
    }
}
```



### filter

根据传入的谓词判断，返回自身或None

```rust
pub fn filter<P>(self, predicate: P) -> Option<T>
where
    P: FnOnce(&T) -> bool,
```

**参数**：

- **predicate**：一个闭包函数作为谓词，返回一个`bool`值
  - 注意`predicate`函数中，`Some`包含的数被**借用**到`predicate`的参数中，在`predicate`函数中使用该参数需要使用解引用符号`*`

**返回值**：

- 如果`predicate`返回`true`，则返回`self`本身的值
- 如果`predicate`返回`false`，则返回`None`

```rust
// 当谓词为真
let some_value: Option<u8> = Some(5);
let res = some_value.filter(|x| if *x < 10 { true } else { false });

println!("{:?}", res)           // Some(5)


// 当谓词为假
let some_value: Option<u8> = Some(5);
let res = some_value.filter(|x| if *x > 10 { true } else { false });

println!("{:?}", res)           // None
```

**源码**：

```rust
#[inline]
#[stable(feature = "option_filter", since = "1.27.0")]
pub fn filter<P>(self, predicate: P) -> Self
where
	P: FnOnce(&T) -> bool,
{
    if let Some(x) = self {
        if predicate(&x) {
            return Some(x);
        }
    }
    None
}
```



### or

判断`self`是否为`Some`，返回`Some`本身或者传入参数的值

```rust
pub fn or(self, optb: Option<T>) -> Option<T>
```

**参数**：

- **optb**：当`self`为None时，`or`函数把`optb`作为返回值

**返回值**：

- 当`self`为`Some`时，返回`Some`本身
- 当`self`为`None`时，返回传入的`optb`的值

```rust
// 当self为Some时
let some_value: Option<u8> = Some(5);
let res = some_value.or(Some(6));
println!("{:?}", res)           // Some(5)

// 当self为None时
let some_value: Option<u8> = None;
let res = some_value.or(Some(6));
println!("{:?}", res) 			// Some(6)
```

**源码**：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn or(self, optb: Option<T>) -> Option<T> {
    match self {
        Some(x) => Some(x),
        None => optb,
    }
}
```



### or_else

判断`self`是否为`Some`，返回`Some`本身或者传入函数的返回值

```rust
pub fn or_else<F>(self, f: F) -> Option<T>
where
    F: FnOnce() -> Option<T>,
```

参数：

- **f**：当`self`为None时，`or_else`函数返回`f`函数的返回值

返回值：

- 当`self`为`Some`时，返回`Some`本身
- 当`self`为`None`时，返回传入的`f`函数的返回值

```rust
// 当self为Some时
let some_value: Option<u8> = Some(5);
let res = some_value.or_else(|| Some(6));
println!("{:?}", res)           // Some(5)

// 当self为None时
let some_value: Option<u8> = None;
let res = some_value.or_else(|| Some(6));
println!("{:?}", res) 			// Some(6)
```

**源码**：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn or_else<F>(self, f: F) -> Option<T>
where
	F: FnOnce() -> Option<T>,
{
    match self {
        Some(x) => Some(x),
        None => f(),
    }
}
```



### xor

把`self`和`optb`做异或判断，如果 `self`，`optb` 之一恰好是 `Some`，则返回 `Some`，否则返回 `None`。

```rust
pub fn xor(self, optb: Option<T>) -> Option<T>
```

**参数**：

- **optb**：需要做异或的参数

**返回值**：

- 如果 `self`，`optb`只要有一个是`Some`，则哪个是`Some`就返回哪个`Some`
- 如果 `self`，`optb`两个都是`None`，则返回`None`

**源码**：

```rust
#[inline]
#[stable(feature = "option_xor", since = "1.37.0")]
pub fn xor(self, optb: Option<T>) -> Option<T> {
    match (self, optb) {
        (Some(a), None) => Some(a),
        (None, Some(b)) => Some(b),
        _ => None,
    }
}
```



### insert

用于把`Option`容器中的值**替换成一个新值**，并**返回这个值的可变引用**。

**无论 `Option`原来的状态是什么，调用后它都会变成 `Some`**，并且如果原来有值，那个旧值会被替换掉。

```rust
pub fn insert(&mut self, value: T) -> &mut T
```

**参数**：

- **value**：需要被插入的值

**返回值**：

- 返回替换后的值的可变引用

```rust
// 向 None 中插入值
let mut maybe_name: Option<String> = None;
let name_ref = maybe_name.insert("Alice".to_string());

// 由于返回的是可变引用，我们可以直接修改它
name_ref.push_str(" Smith");
println!("修改后: {:?}", maybe_name); // 输出: Some("Alice Smith")



// 替换 Some 中的旧值
let mut number = Some(10);
// 替换旧值 10，返回新值 42 的可变引用
let new_num_ref = number.insert(42);
println!("替换后: {:?}", number); // 输出: Some(42)

// 同样可以直接修改
*new_num_ref += 1;
println!("再次修改后: {:?}", number); // 输出: Some(43)
```

源码：

```rust
#[must_use = "if you intended to set a value, consider assignment instead"]
#[inline]
#[stable(feature = "option_insert", since = "1.53.0")]
pub fn insert(&mut self, value: T) -> &mut T {
    *self = Some(value);

    // SAFETY: 上面的代码刚刚填满了该选项
    unsafe { self.as_mut().unwrap_unchecked() }
}
```



### get_or_insert

如果self为None，则将`None`**替换成一个新值**，并**返回这个值的可变引用**。新值改变，旧值也会改变

否则返回Some包含的值的可变引用

```rust
pub fn get_or_insert(&mut self, value: T) -> &mut T
```

参数：

- **value**：需要被插入的值

**返回值**：

- 返回替换后的值的可变引用

```rust
// 当self为Some时
let mut some_value = Some(66);
let res = some_value.get_or_insert(77);
println!("{}", res); // 66
*res += 10; // 可以改变
println!("{}", res); // 76


// 当self为None时
let mut some_value: Option<i32> = None;
let res = some_value.get_or_insert(77);
println!("{}", res); // 77
*res += 10; // 可以改变
println!("{}", res); // 87
```

源码：

```rust
#[inline]
#[stable(feature = "option_entry", since = "1.20.0")]
pub fn get_or_insert(&mut self, value: T) -> &mut T {
    if let None = *self {
        *self = Some(value);
    }

    // SAFETY: 在上面的代码中，用于 `self` 的 `None` 变体将被替换为 `Some` 变体。
    //
    unsafe { self.as_mut().unwrap_unchecked() }
}
```





### get_or_insert_with

如果`self`为`None`，则把`f`的返回值放入`Some`中，并返回该值的可变引用。新值改变，旧值也会改变

如果`self`为`Some(T)`，则返回`T`的可变引用

```rust
pub fn get_or_insert_with<F>(&mut self, f: F) -> &mut T
where
    F: FnOnce() -> T,
```

参数：

- **f**：当`self`为`None`时，触发`f`函数，并将f函数的返回值返回出去

返回值：

- 若`self`为`None`，则返回`fn()`返回值的可变引用 
- 若`self`为`Some(T)`，则返回`T`的可变引用

```rust
// 当self为Some时
let mut some_value = Some(66);
let res = some_value.get_or_insert_with(|| 111);
println!("{}", res); // 66
*res += 10; // 可以改变
println!("{}", res); // 76

println!("{:?}", some_value); // 76， 原来的值也被改变

// 当self为None时
let mut some_value: Option<i32> = None;
let res = some_value.get_or_insert_with(|| 222);
println!("{}", res); // 222
*res += 10; // 可以改变
println!("{}", res); // 232
```

源码：

```rust
#[inline]
#[stable(feature = "option_entry", since = "1.20.0")]
pub fn get_or_insert_with<F>(&mut self, f: F) -> &mut T
where
	F: FnOnce() -> T,
{
    if let None = self {
        *self = Some(f());
    }

    // SAFETY: 在上面的代码中，用于 `self` 的 `None` 变体将被替换为 `Some` 变体。
    //
    unsafe { self.as_mut().unwrap_unchecked() }
}
```



### get_or_insert_default

`Option`为 `None`时，会使用`T`**类型的默认值**（如：i32的默认值是0）进行插入，并返回一个指向内部值的可变引用

```rust
pub fn get_or_insert_default(&mut self) -> &mut T
where
    T: Default,
```

返回值：

- 若`self`为`None`，则返回`Option<T>`中**T类型的默认值**的可变引用
- 若`self`为`Some`，则返回`Some`包含的值的可变引用

```rust
// 当self为Some时
let mut some_value = Some(66);
let res = some_value.get_or_insert_default();
println!("{}", res); // 66
*res += 10; // 可以改变
println!("{}", res); // 76

// 当self为None时
let mut some_value: Option<i32> = None;
let res = some_value.get_or_insert_default();
println!("{}", res); // 0    i32类型的默认值
*res += 10; // 可以改变
println!("{}", res); // 10
```



源码：

```rust
#[inline]
#[unstable(feature = "option_get_or_insert_default", issue = "82901")]
pub fn get_or_insert_default(&mut self) -> &mut T
where
	T: Default,
{
    self.get_or_insert_with(T::default)
}
```



### take



```rust

```

参数：

返回值：

源码：

```rust

```



### replace



```rust

```

参数：

返回值：

源码：

```rust

```



### zip



```rust

```

参数：

返回值：

源码：

```rust

```



### zip_with



```rust

```

参数：

返回值：

源码：

```rust

```



### unzip



```rust

```

参数：

返回值：

源码：

```rust

```



### copied



```rust

```

参数：

返回值：

源码：

```rust

```



### cloned

```rust

```

参数：

返回值：

源码：

```rust

```





```rust

```

参数：

返回值：

源码：

```rust

```



### copied



```rust

```

参数：

返回值：

源码：

```rust

```



### cloned



```rust

```

参数：

返回值：

源码：

```rust

```



### transpose



```rust

```

参数：

返回值：

源码：

```rust

```



### flatten



```rust

```

参数：

返回值：

源码：

```rust

```











## 4.关联函数















































































:::tip

由于`match`穷尽性的要求，`Rust`要求你必须处理`None`，从而减少不安全的行为。

:::



## 常用方法



在前面，我们已经通过 `match` 模式匹配来使用 `Option`。不过，`Option` 自带一些非常实用的方法，可以让常见操作更简洁。

##### is_some() / is_none()



判断当前是否是 `Some` 或 `None`。

```
let x = Some(10);

assert!(x.is_some());   // x 确实是 Some
assert!(!x.is_none());  // 所以它不是 None
```



这两个方法常用于快速分支判断。

##### unwrap_or()



在有值时取出内容，否则给一个默认值。

```
let a = Some(5);
let b: Option<i32> = None;

let v1 = a.unwrap_or(0); // 得到 5
let v2 = b.unwrap_or(0); // 没有值，用默认 0
println!("v1={}, v2={}", v1, v2);
```



##### map()



对 `Some` 中的值做变换，如果是 `None` 就保持不变。

```
fn double(n: i32) -> i32 {
    n * 2
}

let y = Some(7);
let doubled = y.map(double); // Some(14)
println!("doubled={:?}", doubled);
```



此处的`y.map(double)`，意思是如果`y`里面是`Some`，那么把`Some`里面的`T`作为参数传给` double`，如果是`None`就啥也不干。

##### and_then()



常用于链式调用：

1. 如果是 `Some`，就把里面的`T`交给一个返回 `Option` 的函数处理
2. 如果是 `None`，就直接传递 `None`

```
fn to_even(n: i32) -> Option<i32> {
    if n % 2 == 0 {
        Some(n)
    } else {
        None
    }
}

let z = Some(10);
let res1 = z.and_then(to_even); // Some(10)，因为10是偶数
println!("res1={:?}", res1);

let z2 = Some(11);
let res2 = z2.and_then(to_even); // None，因为11不是偶数
println!("res2={:?}", res2);
```