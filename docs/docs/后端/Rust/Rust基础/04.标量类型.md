# 标量类型

## 1.标量类型

### 1.1 整数类型

`Rust` 提供了丰富的整数类型，每种都明确指定**位数**和**符号性**。你可以根据需要选择合适的类型，既不会浪费内存，又能保证计算精度。

整数类型分为两大类：有符号（`i` 开头）和无符号（`u` 开头）。有符号可以表示正数、负数和零，无符号只能表示非负数。



#### 1.1.1 固定宽度整数

**有符号整数**

每一个有符号的变体可以储存包含从 -2<sup>n-1</sup> 到 2<sup>n-1</sup> - 1 在内的数字，这里 *n* 是变体使用的**位数**。

| 类型   | 长度    | 范围                                   |
| :----- | :------ | :------------------------------------- |
| `i8`   | 8-bit   | [-2<sup>7</sup>,  2<sup>7</sup>-1]     |
| `i16`  | 16-bit  | [-2<sup>15</sup>,  2<sup>15</sup>-1]   |
| `i32`  | 32-bit  | [-2<sup>31</sup>,  2<sup>31</sup>-1]   |
| `i64`  | 64-bit  | [-2<sup>63</sup>,  2<sup>63</sup>-1]   |
| `i128` | 128-bit | [-2<sup>127</sup>,  2<sup>127</sup>-1] |

**无符号整数**

无符号的变体可以储存从 0 到 2<sup>n</sup> - 1 的数字

| 类型   | 长度    | 范围                    |
| :----- | :------ | :---------------------- |
| `u8`   | 8-bit   | [0 ,  2<sup>8</sup>-1]  |
| `u16`  | 16-bit  | [0,  2<sup>16</sup>-1]  |
| `u32`  | 32-bit  | [0,  2<sup>32</sup>-1]  |
| `u64`  | 64-bit  | [0,  2<sup>64</sup>-1]  |
| `u128` | 128-bit | [0,  2<sup>128</sup>-1] |



#### 1.1.2 架构相关整数

除了以上有符号和无符号的整数，还有两个根据架构相关的整数，`isize`和`usize`

`isize` 和 `usize` 的位数 `n` 取决于目标架构：

- 在 32 位系统（如 x86）上 `n = 32`
- 在 64 位系统（如 x64）上 `n = 64`

| 类型    | 长度                                  | 范围                                                         |
| :------ | :------------------------------------ | :----------------------------------------------------------- |
| `isize` | 32位系统：32-bit<br/>64位系统：64-bit | 32位系统：-2<sup>31</sup>  到  2<sup>31</sup>-1<br/>64位系统：-2<sup>63</sup>  到  2<sup>63</sup>-1 |
| `usize` | 32位系统：32-bit<br/>64位系统：64-bit | 32位系统：0  到  2<sup>32</sup>-1<br/>64位系统：0  到  2<sup>64</sup>-1 |



架构相关的整数，可以在按照系统自适应整形大小。

如果你想知道某个类型到底占用多少字节，可以使用 `std::mem::size_of`：

```rust
use std::mem;
println!("i8: {} bytes", mem::size_of::<i8>());    // 1
println!("i32: {} bytes", mem::size_of::<i32>());  // 4
println!("i64: {} bytes", mem::size_of::<i64>());  // 8
println!("usize: {} bytes", mem::size_of::<usize>()); // 4 或 8
```

`size_of` 返回的是字节数，不是位数。1 字节 = 8 位，所以 `i32` 占用 4 字节 = 32 位。



#### 1.1.3 默认整型

上面说到rust具有类型推导，当声明一个整数时，默认为`i32`

当直接写整数字面量时，默认使用 `i32`：

```rust
let x = 42; // 推断为 i32
```

这是因为 `i32` 在大多数场景下是性能和空间的最佳平衡点，即使在 64 位系统上也是如此。





#### 1.1.4 整数溢出

`Rust` 的程序构建时，分为两种模式，`debug`调试构建 和 `release`发布构建。

在 `debug` 模式下，会有更多的调试信息输出，一般用于开发环境。而 `release` 下会对代码进行更大幅度的优化，运行效率更高，一般用语正式发布环境。

当一个整数发生溢出的时候，在两个环境下效果也不同。

在 `debug` 模式下，如果整数溢出，此时会直接报错，在 `Rust` 中称为 `panic`。这会导致整个程序直接终止。

但是在 `release` 下，如果溢出会发生环绕。

比如:

```rust
let mut x: u8 = 255;
x += 1;
println!("x: {}", x);
```

这段代码在 `debug` 模式下直接报错退出，但是在 `release` 下输出 `x: 0`。因为 255 已经是 `u8` 的最大值了，当再加一个数，就会重新变回最小的值，这个过程称为环绕。

其实环绕大部分情况下是一个非常危险的操作，在开发的时候，`Rust`倾向于直接把这个行为作为一个错误报告给开发者，让开发者可以修改代码逻辑，或者更改更大的类型。

但是在实际发布环境，程序崩溃往往会给用户带来不好的体验，那么`Rust`就不再把它当做一个错误处理了。

------

### 1.2 浮点数类型

`Rust`有两种浮点数类型：`f32`（单精度）和`f64`（双精度），分别占 32 位和 64 位。它们都遵从 IEEE-754 标准。

```rust
let x = 2.0;           // f64（默认，推荐）
let y: f32 = 3.0;      // f32（显式标注）

// 科学记数法
let large = 1e6;       // 1000000.0 (f64)
let small = 1e-6;      // 0.000001 (f64)
```

**一个浮点数类型的字面量默认为 `f64`，与现代CPU性能相近但精度更高。**







### 1.3 布尔类型

布尔类型只表示两种真值，不与数字互转，这能防止很多隐式转换陷阱。与控制流（`if`/`while`）结合时，编译器要求条件表达式必须是 `bool`，从而让代码更清晰、更安全。

```rust
let t = true;                  // bool类型
let f: bool = false;           // 显式标注

// 布尔运算
let and_result = t && f;       // false
let or_result = t || f;        // true  
let not_result = !t;           // false
```

**特点**：占用1字节，只能是`true`或`false`，不能与数字隐式转换。

------



### 1.4 字符类型

`char` 表示一个 Unicode 标量值，它可以存储英文字母，中文字符，拉丁文等等。使用单引号`''`来声明。

```rust
let c = 'z';                   // ASCII字符
let unicode = 'ℤ';             // Unicode字符
let chinese = '中';             // 中文
```

Rust 的 `char` 类型的大小为**四个字节**(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。

在 Rust 中，拼音字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 `char` 值。

Unicode 标量值包含从 `U+0000` 到 `U+D7FF` 和 `U+E000` 到 `U+10FFFF` 在内的值。



### 1.5 never 类型

`Rust` 还有一个特殊的类型叫做 `!`，读作 "never"（永不类型）。这个类型表示计算永远不会正常完成。

`!` 没有实际的值，因为对应的计算永远不会返回结果，可以转换为任何其他类型，主要用于表示程序会永久阻塞或直接退出的情况。

比如说`loop` 循环：

```rust
loop {
	// 死循环
}
```

这是一个表达式，它会返回一个值，而死循环永远不退出，因此外部其实永远得不到这个值，那么死循环返回的值就是一个 `!` 表示 `never` 类型。

可以尝试用变量接收：

```rust
let n: ! = loop{ };
```

变量`n`会被自动推断为`!`类型。

此外，`!` 可以转换为任意其它类型：

```rust
let other_num: i32 = loop{};
let other_flo: f32 = loop{};
let other_bol: bool = loop{};
```

以上代码都是合法的，那么有人就要问：“转换出来的具体值是多少？”。

答案是没有值，因为`!`表示永远不会达到的地方，那么以上三个变量根本就不可能会被使用，那么它的值是多少也根本不重要。

当然不是所有的`loop`返回的都是`!`，只有死循环才是。也有其它情况会返回`!`，在后续的博客会讲到，现在只要知道存在这样一个类型即可。





## 2.数值字面量的修饰

在 Rust 中，数值字面量（包括整数和浮点数）支持多种表示方式，这些方式不仅适用于整数类型，也适用于浮点数类型。

### 2.1 进制表示

`Rust` 允许通过前缀不同，可以决定一个数值字面量的进制：

- 无前缀：默认十进制（如 `42`）
- `0x`：十六进制（如 `0x2A` == 42）
- `0o`：八进制（如 `0o52` == 42）
- `0b`：二进制（如 `0b101010` == 42）
- 大小写均可：`0xFF` 与 `0xff` 等价

示例：

```rust
// 进制表示
let decimal = 98;    // 十进制
let hex = 0xff;      // 十六进制
let octal = 0o77;    // 八进制  
let binary = 0b111;  // 二进制
```

------

### 2.2 下划线分隔符

对于一个数值，允许通过 `_` 进行分割，仅用于提升可读性，没有数值语义影响。例如 `1_000_000` 与 `1000000` 完全相同；二进制/十六进制中也可用来分组位。

示例：

```rust
let a = 1_000;        // 等价于 1000
let b = 1_000_000;    // 等价于 1000000

let pi = 3.141_592;   // 等价于 3.141592
let c = 10_000.5;     // 等价于 10000.5

let bin = 0b0001_0010; // 等价于 0b00010010 (十进制18)
let hex = 0x12ab_34cd; // 等价于 0x12ab34cd
let oct = 0o123_456;   // 等价于 0o123456
let byte = 0b1111_0000u8; // 等价于 240u8
```





### 2.3 类型后缀

对于数值字面量，可以通过修改后缀来决定其类型：

```rust
// 整数类型后缀
let typed = 123i64;            // i64 类型
let unsigned = 456u32;         // u32 类型
let long_num = 789i128;        // i128 类型
// 浮点数类型后缀
let float32 = 1.0f32;          // f32 类型
let float64 = 2.0f64;          // f64 类型
```

类型后缀把字面量本身的类型在语法层面固定为某个具体类型。它发生在编译期，只影响该字面量节点的静态类型。





### 2.4 科学计数法

科学计数法主要用于浮点数，表示非常大或非常小的数：

```rust
let large = 1e6;       // 1000000.0 (f64)
let small = 1e-6;      // 0.000001 (f64)
let middle = 2.5e3;    // 2,500.0 (f64)
```

- `e` 前面的数字是**系数**（有效数字部分）
- `e` 后面的数字是**指数**（10的幂次）
- 整个表达式表示：系数×10指数系数×10指数

此处可以使用大写 `E` 或小写 `e`，指数部分可以是正数或负数（使用 `+` 或 `-`），系数可以是整数或浮点数，默认推断为 `f64` 类型，同样可以使用后缀指定类型：`1e6f32`。



### 2.5 字节字面量

字节字面量是整型中 `u8` 的特殊表示法：

```rust
let byte: u8 = b'A'; // 字节字面量（u8）
```

字节字面量 `b'A'`：表示一个 `u8`（0~255）的字节值，必须是 ASCII 范围内的单字符。示例：`b'A' == 65u8`。非 ASCII 字符（如 `b'中'`、`b'国'`）是非法的。







## 3.类型转换

在 `Rust` 中，**类型转换必须是显式的**，不能像其他语言那样自动隐式转换。需要使用 `as` 关键字来明确告诉编译器要进行转换。

- **从小类型转大类型**：比如 `i32` → `i64` 是安全的，因为大类型能完全容纳小类型的值，不会丢失数据。

```rust
let small: i32 = 42;
let large: i64 = small as i64;  // 安全转换，值不变
```

- **从大类型转小类型**： 比如 `i32` → `u8` 如果原始值超出了目标类型的范围，会发生截断：

```rust
let big: i32 = 300;
let small: u8 = big as u8; // 300 超出了 u8 的范围(0-255)，结果变成 44
// 相当于 300 % 256 = 44
```

- **浮点数转整数**：小数部分会被直接丢弃（向零取整）：

```rust
let pi = 3.99;
let whole = pi as i32; // 变成 3，小数部分没了

let negative = -2.7;
let neg_whole = negative as i32; // 变成 -2
```

如果浮点数太大，超出了目标整数类型的范围，结果是未定义的，要特别小心。

- **字符转整数**：字符可以转换成它对应的 Unicode 码点值：

```rust
let letter = 'A';
let code = letter as u32; // 65，A 的 Unicode 值

let star = '⭐';
let star_code = star as u32; // 11088，星星的 Unicode 值
```

- **布尔值转整数**：布尔值转换很简单，`true` 变成 1，`false` 变成 0：

```rust
let yes = true as u8;   // 1
let no = false as i32;  // 0
```

这种转换在需要将逻辑值参与数学运算时很有用。





## 4.常量与静态

### 4.1 常量

常量在程序运行期间值永远不变，使用 `const` 声明：

```rust
const MAX_POINTS: u32 = 100_000;
const PI: f64 = 3.14159;
const MESSAGE: &str = "Hello";
```

**常量必须进行类型标注**，指明类型。

与 `let` 的区别：常量必须是编译期可求值的表达式，通常会被内联到使用处，没有固定内存地址；可在任意作用域声明（包括全局），且总是不可变。

比如以下代码就是错误的：

```rust
let mut num = 1;
const NUM: i32 = num; // 错误
```

常量 `NUM` 依赖了一个变量 `num`，变量在运行时才能确定值，导致 `NUM` 无法在编译期得到确定值，因此报错。



### 4.2 静态变量

静态变量具有`static`生命周期，在程序整个运行期间有效：

```rust
static GLOBAL_COUNT: i32 = 0;
static mut COUNTER: i32 = 0;
```

`static` 具有固定内存地址，可通过引用取地址。`static` 也要求必须进行类型标注。`static`可以声明为`mut`，定义一个全局可变的变量。





