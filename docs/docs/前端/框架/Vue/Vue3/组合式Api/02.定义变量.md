# 定义变量

## 1.ref()

### 1.1 作用

`ref()`函数用来定义变量，一般用来定义一个基本数据类型的变量

`ref()`也可以定义复杂数据类型，但是内部也会`reactive()`转化为响应式对象

### 1.2 语法

接受一个内部值，返回一个响应式的、可更改的 ref 对象，此对象只有一个指向其内部值的属性 `.value`。

```ts
function ref<T>(value: T): Ref<UnwrapRef<T>>

interface Ref<T> {
  value: T
}
```

使用语法如下：

:::code-group

```js [Js]
import {ref} from 'vue'

// 定义基本数据类型
const num=ref(123)
const str=ref('你好')
const bool=ref(true)
const none=ref(null)
const no=ref(undefined)

// 定义复杂数据类型
const obj=ref({
    num:123
})


const arr=ref([1,2,3,4,5])
```

```ts [Ts]
import {ref} from 'vue'

// 定义基本数据类型
const num=ref<number>(123)
const str=ref<string>('你好')
const bool=ref<boolean>(true)
const none=ref<null>(null)
const no=ref<undefined>(undefined)

// 定义复杂数据类型
interface Item{
    num:number
}
const obj=ref<Item>({
    num:123
})


const arr=ref<Array<number>>([1,2,3,4,5])
```

:::



### 1.3 使用

ref()返回一个Ref对象，其中有一个value属性存储着我们定义的值

也就是说ref()定义的数据都需要以`.value`的方式使用

```js
const num=ref(123)
console.log(num.value) // 123

const str=ref('你好')
console.log(str.value) // '你好'

const obj=ref({
    num:123
})
console.log(obj.value.num) // 123

const obj=ref([1,2,3])
console.log(obj.value[0]) // 1
```







## 2.reactive()

### 2.1 作用

返回一个对象的响应式代理。Vue3用来定义复杂数据类型，注意不可以定义基本数据类型

```ts
function reactive<T extends object>(target: T): UnwrapNestedRefs<T>
```



### 2.2 语法

使用`reactive()`定义对象如下所示

:::code-group

```js [Js]
import { reactive } from 'vue'

const obj=reactive({
    name:'坤坤'
})

const arr=reactive([1,2,3])
```

```ts [Ts]
import { reactive } from 'vue'

interface Item{
    name:string
}
const obj=reactive<Item>({
    name:'坤坤'
})

const arr=reactive<Array<number>>([1,2,3])
```

:::



### 2.3 使用

使用`reactive()`定义的数据不需要像`ref()`一样.value才能获取到值，`reactive()`定义的数据可以直接使用

```js
const obj=reactive({
    name:'坤坤'
})
console.log(obj.name) // 坤坤

const arr=reactive([1,2,3])
console.log(arr[0]) // 1
```



