# 动态内存

C++ 程序中的内存分为两个部分：

- **栈**：在函数内部声明的所有变量都将占用栈内存。
- **堆**：这是程序中未使用的内存，在程序运行时可用于动态分配内存。

很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。

在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 **new** 运算符。

如果您不再需要动态分配的内存空间，可以使用 **delete** 运算符，删除之前由 new 运算符分配的内存。

## 1.new和delete运算符

```c++
new data-type
```

**data-type** 可以是包括数组在内的**任意内置的数据类型**，也可以是包括类或结构在内的用户自定义的任何数据类型。

new运算符是请求地址，所以他返回一个地址，我们需要用指针来指向这个地址

```c++ {1,2}
int *p = NULL;
p = new int;

cout << p <<endl;  // 指针p指向的地址
cout << *p <<endl;	// 指针p指向地址中的值，默认为0
```

可以在请求地址时，给上一个默认值

```c++ {2}
int *p = NULL;
p = new int(100);

cout << p <<endl;  // 指针p指向的地址
cout << *p <<endl;	// 100
```

如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 `new` 运算符是否返回 `NULL` 指针，并采取以下适当的操作：

```c++ {2}
int* p  = NULL;
if( !(p  = new int ))
{
   cout << "Error: out of memory." <<endl;
   exit(1);
}
```

当确定分配的内存后面不会再使用了，需要使用`delete`手动释放内存，不然可能会造成内存泄漏

```c++ {4}
int *p = NULL;
p = new int(100);

delete p;
```



## 2.数组的动态内存分配

```c++
// 动态分配,数组长度为 m
int *array=new int [m];
 
//释放内存
delete [] array;
```

二维数组

```c++
int **array;
// 假定数组第一维长度为 m， 第二维长度为 n
// 动态分配空间
array = new int *[m];
for( int i=0; i<m; i++ )
{
    array[i] = new int [n];
}
//释放
for( int i=0; i<m; i++ )
{
    delete [] array[i];
}
delete [] array;
```



## 3.对象的动态内存分配

对象与简单的数据类型没有什么不同。

```c++
#include <iostream>
using namespace std;
 
class Box
{
   public:
      Box() { 
         cout << "调用构造函数！" <<endl; 
      }
      ~Box() { 
         cout << "调用析构函数！" <<endl; 
      }
};
 
int main( )
{
   Box* myBoxArray = new Box[4];
 
   delete [] myBoxArray; // 删除数组
   return 0;
}
```

如果要为一个包含四个 Box 对象的数组分配内存，构造函数将被调用 4 次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（4次）。

当上面的代码被编译和执行时，它会产生下列结果：

```
调用构造函数！
调用构造函数！
调用构造函数！
调用构造函数！
调用析构函数！
调用析构函数！
调用析构函数！
调用析构函数！
```