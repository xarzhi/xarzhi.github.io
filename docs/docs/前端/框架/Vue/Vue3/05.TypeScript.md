# 五、TypeScript

## 1.6 class类

### 1.6.1 基础使用

```ts
class Person 
{
    gender: string
    age: number 

    constructor(gender:string, age: number) {
        this.gender = gender
        this.age = age
    }

    eat(food: string):void {
        console.log(food);
    }
}


const obj = new Person('张三', 18)

console.log(obj.gender);
console.log(obj.age);
```





### 1.6.2 继承父类extends

```ts
class Person 
{
    gender: string
    age: number 

    constructor(gender:string, age: number) {
        this.gender = gender
        this.age = age
    }

    eat(food: string):void {
        console.log(food);
    }
}

class Wof extends Person {}


const obj = new Person('张三', 18)
console.log(obj.gender);
console.log(obj.age);


const obj2 = new Wof('神龙教主', 19)
console.log(obj2);
```



### 1.6.3 实现接口implements

- 继承  两个类、子有父的属性和方法
- 实现接口  一个接口、一个类    类必须按照接口中定一个规则去实现

```ts
interface Animal 
{
    gender: string
    eat(): void
}

// const dog: Animal = {}

class Dog implements Animal {
    gender: string = '公'
    eat() {

    }
}
```



### 1.6.4 修饰符

**public** 默认修饰符，TypeScript中类中的成员默认为public

**private** 类的成员不能在类的外部访问，子类也不可以

**protected** 类的成员不能在类的外部访问，但是子类中可以访问。如果一个类的构造函数，修饰符为protected，那么此类只能被继承，无法实例化。

**readonly** 关键字`readonly`可以将实例的属性，设置为只读

```ts
					
	public  	 自身	子类	外部
	protected   自身	子类 
	private     自身


class Animal
{
    public a = 1
    protected b = 2
    private c = 3
}

class Dog extends Animal {

    readonly d = 4

    constructor() {
        super()
        console.log(1, this.a)
    }
}

const dog1 = new Dog
console.log(2, dog1.a)
console.log(3, dog1.d)
// dog1.d = 44
```







## 1.11 ts类型修饰符



public 		  **默认修饰符**，TypeScript中类中的成员**默认为public**

**private** 		**私有修饰符**，类的成员**不能在类的外部访问，子类也不可以**

**protected**    **保护修饰符**，类的成员**不能在类的外部访问**，但是**子类中可以访问**。如果一个类的构造函数，修饰符为protected，那么此类**只能被继承，无法实例化。**

**readonly**      关键字`readonly`可以将实例的属性，设置为**只读**

```ts
class Boo {
  public name: string
  constructor (theName: string) {
    this.name = theName
  }
}

class Far {
  constructor (public name: string) {
  }
}



class Obj {
  public a: number = 555;
  private b: string = "dsfdsf";
}

let obj = new Obj();
console.log(obj.a);
console.log(obj.b);
```





## 1.14 tsconfig.json

```ts
include：指定需要编译文件所在的目录。
exclude：指定不需要编译文件所在目录。

compilerOptions  编译选项
  "target": "ES3",    		// 编译后的js版本
  "outDir": "./dist", 		// 编译目录
  "removeComments": true, // 删除注释
  "strict": true,				  // 开启所有严格的类型检查
      const data2 = (a) => {
          console.log(a)
      }
  "alwaysStrict": true,   // 在代码中注入'use strict'
  "noImplicitAny": true,  // 不允许【隐式】的any类型
  "baseUrl": "./",  			// 解析非相对模块名的基准目录
  "paths": {  		 		  	// 模块名到基于 baseUrl的路径映射的列表。
    "@/*": ["./src1/*"]
  },
	"skipLibCheck": true    // 跳过所有.d.ts文件语法检查

      declare let a: string
      let b = 111
      b = 222

references：项目引用

files：指定被编译的文件。
extends：指定要继承的配置文件。
```

自定义

```json
//自用版-添加其他看下面
{
    /* 根选项 */
    "include": ["./src/**/*"], // 指定被编译文件所在的目录
    "exclude": [], // 指定不需要被编译的目录
    //使用小技巧：在填写路径时 ** 表示任意目录， * 表示任意文件。

    /* 项目选项 */
    "compilerOptions": {
        "target": "ES6", // 目标语言的版本
        "module": "commonjs", // 生成代码的模板标准
        "lib": ["DOM","ES5","ES6","ES7","ScriptHost"], // TS需要引用的库
        "outDir": "./dist", // 指定输出目录
        "rootDir": "./", // 指定输出文件目录(用于输出)，用于控制输出目录结构
        "allowJs": true, // 允许编译器编译JS，JSX文件
        "checkJs": true, // 允许在JS文件中报错，通常与allowJS一起使用
        "removeComments": true, // 删除注释
        "esModuleInterop": true, // 允许export=导出，由import from 导入

        /* 严格检查选项 */
        "strict": true, // 开启所有严格的类型检查
        "alwaysStrict": true, // 在代码中注入'use strict'
        "noImplicitAny": true, // 不允许隐式的any类型
        "noImplicitThis": true, // 不允许this有隐式的any类型
        "strictNullChecks": true, // 不允许把null、undefined赋值给其他类型的变量
        "strictBindCallApply": true, // 严格的bind/call/apply检查
        "strictFunctionTypes": true, // 不允许函数参数双向协变
        "strictPropertyInitialization": true, // 类的实例属性必须初始化

        /* 额外检查 */
        "noUnusedLocals": true,//是否检查未使用的局部变量
        "noUnusedParameters": true,//是否检查未使用的参数
        "noImplicitReturns": true,//检查函数是否不含有隐式返回值
        "noImplicitOverride": true,//是否检查子类继承自基类时，其重载的函数命名与基类的函数不同步问题
        "noFallthroughCasesInSwitch": true,//检查switch中是否含有case没有使用break跳出
        "noUncheckedIndexedAccess": true,//是否通过索引签名来描述对象上有未知键但已知值的对象
        "noPropertyAccessFromIndexSignature": true,//是否通过" . “(obj.key) 语法访问字段和"索引”( obj[“key”])， 以及在类型中声明属性的方式之间的一致性

        /* 实验选项 */
        "experimentalDecorators": true,//是否启用对装饰器的实验性支持，装饰器是一种语言特性，还没有完全被 JavaScript 规范批准
        "emitDecoratorMetadata": true,//为装饰器启用对发出类型元数据的实验性支持

        /* 高级选项 */
        "forceConsistentCasingInFileNames": true,//是否区分文件系统大小写规则
        "extendedDiagnostics": false,//是否查看 TS 在编译时花费的时间
        "noEmitOnError": true,//有错误时不进行编译
        "resolveJsonModule": true,//是否解析 JSON 模块
    },
}
```

