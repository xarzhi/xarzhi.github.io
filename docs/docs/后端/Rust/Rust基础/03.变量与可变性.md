# 变量与可变性

## 1.变量

在`rust`中，声明变量使用`let`关键字

- 默认情况下，变量是不可变的（immutable）
- let声明的变量，可以给出变量类型，也可以不给，不给的话rust会自动推导该变量的类型
  - 例如声明数值类型的变量，数值类型有i32、u32等等，若不给出变量类型，则默认被推导为i32

```rust
fn main(){
    let num = 666;
    num=777;
    println!("{}",num);        
}
```

上述代码会报以下错误：

![image-20251130192032493](https://gitee.com/xarzhi/picture/raw/master/img/image-20251130192032493.png)



如果想让一个变量可变，需要使用`mut`关键字

```rust
fn main(){
    let mut num=666;
    num=777;
    println!("{}",num);         // 777
}
```





## 2.常量

常量（constant），常量在绑定值以后也是不可变的，但是它与不可变的变量有很多区别：

- **不可以使用 mut**，**常量永远都是不可变的**
- 声明常量使用 `const` 关键字，它的**类型必须被标注**
- 常量可以在任何作用域内进行声明，包括全局作用域
- 常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值

在程序运行期间，常量在其声明的作用域内一直有效

命名规范：Rust里常量使用全大写字母，每个单词之间用下划线分开，例如：MAX_POINTS

- 例子: `const MAX_POINTS:u32= 100_000;`





## 3.Shadowing

可以使用相同的名字声明新的变量，新的变量就会shadow（隐藏）之前声明的同名变量

在后续的代码中这个变量名代表的就是新的变量

```rust
fn main() {
    let x = 5;
    let x = x + 1;
    let x = x + 2;
}
```

shadow和把变量标记为muf是不一样的：

- 如果不使用let关键字，那么重新给非 mut的变量赋值会导致编译时错误

- 而使用let声明的同名新变量，也是不可变的

- **使用let声明的同名新变量，它的类型可以与之前不同**

  ```rsut
  fn main() {
      let spaces="     ";
      let spaces=spaces.len();
  }
  ```

  



