## 2.数值字面量的修饰

在 Rust 中，数值字面量（包括整数和浮点数）支持多种表示方式，这些方式不仅适用于整数类型，也适用于浮点数类型。

### 2.1 进制表示

`Rust` 允许通过前缀不同，可以决定一个数值字面量的进制：

- 无前缀：默认十进制（如 `42`）
- `0x`：十六进制（如 `0x2A` == 42）
- `0o`：八进制（如 `0o52` == 42）
- `0b`：二进制（如 `0b101010` == 42）
- 大小写均可：`0xFF` 与 `0xff` 等价

示例：

```rust
// 进制表示
let decimal = 98;    // 十进制
let hex = 0xff;      // 十六进制
let octal = 0o77;    // 八进制  
let binary = 0b111;  // 二进制
```



### 2.2 下划线分隔符

对于一个数值，允许通过 `_` 进行分割，仅用于提升可读性，没有数值语义影响。例如 `1_000_000` 与 `1000000` 完全相同；二进制/十六进制中也可用来分组位。

示例：

```rust
let a = 1_000;        // 等价于 1000
let b = 1_000_000;    // 等价于 1000000

let pi = 3.141_592;   // 等价于 3.141592
let c = 10_000.5;     // 等价于 10000.5

let bin = 0b0001_0010; // 等价于 0b00010010 (十进制18)
let hex = 0x12ab_34cd; // 等价于 0x12ab34cd
let oct = 0o123_456;   // 等价于 0o123456
let byte = 0b1111_0000u8; // 等价于 240u8
```





### 2.3 类型后缀

对于数值字面量，可以通过修改后缀来决定其类型：

```rust
// 整数类型后缀
let typed = 123i64;            // i64 类型
let unsigned = 456u32;         // u32 类型
let long_num = 789i128;        // i128 类型
// 浮点数类型后缀
let float32 = 1.0f32;          // f32 类型
let float64 = 2.0f64;          // f64 类型
```

类型后缀把字面量本身的类型在语法层面固定为某个具体类型。它发生在编译期，只影响该字面量节点的静态类型。





### 2.4 科学计数法

科学计数法主要用于浮点数，表示非常大或非常小的数：

```rust
let large = 1e6;       // 1000000.0 (f64)
let small = 1e-6;      // 0.000001 (f64)
let middle = 2.5e3;    // 2,500.0 (f64)
```

- `e` 前面的数字是**系数**（有效数字部分）
- `e` 后面的数字是**指数**（10的幂次）
- 整个表达式表示：系数×10指数系数×10指数

此处可以使用大写 `E` 或小写 `e`，指数部分可以是正数或负数（使用 `+` 或 `-`），系数可以是整数或浮点数，默认推断为 `f64` 类型，同样可以使用后缀指定类型：`1e6f32`。



### 2.5 字节字面量

字节字面量是整型中 `u8` 的特殊表示法：

```rust
let byte: u8 = b'A'; // 字节字面量（u8）
```

字节字面量 `b'A'`：表示一个 `u8`（0~255）的字节值，必须是 ASCII 范围内的单字符。示例：`b'A' == 65u8`。非 ASCII 字符（如 `b'中'`、`b'国'`）是非法的。











## 4.常量与静态

### 4.1 常量

常量在程序运行期间值永远不变，使用 `const` 声明：

```rust
const MAX_POINTS: u32 = 100_000;
const PI: f64 = 3.14159;
const MESSAGE: &str = "Hello";
```

**常量必须进行类型标注**，指明类型。

与 `let` 的区别：常量必须是编译期可求值的表达式，通常会被内联到使用处，没有固定内存地址；可在任意作用域声明（包括全局），且总是不可变。

比如以下代码就是错误的：

```rust
let mut num = 1;
const NUM: i32 = num; // 错误
```

常量 `NUM` 依赖了一个变量 `num`，变量在运行时才能确定值，导致 `NUM` 无法在编译期得到确定值，因此报错。



### 4.2 静态变量

静态变量具有`static`生命周期，在程序整个运行期间有效：

```rust
static GLOBAL_COUNT: i32 = 0;
static mut COUNTER: i32 = 0;
```

`static` 具有固定内存地址，可通过引用取地址。`static` 也要求必须进行类型标注。`static`可以声明为`mut`，定义一个全局可变的变量。





