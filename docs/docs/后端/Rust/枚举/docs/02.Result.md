### 3.2 Result< T, E >

`Result<T, E>` 用来表达一次运算**可能成功，也可能失败**。定义如下：

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

它有两个变体：

- `Ok(T)` 表示操作成功，携带一个结果值 `T`。
- `Err(E)` 表示操作失败，携带一个错误信息 `E`。

这种设计思想可以让错误处理显式、安全，而不是像某些语言那样抛异常（exception），读代码时一眼就能看出哪里会失败。

比如写一个除法函数，如果除数是 0，显然要报错：

```rust
fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err("除数不能为0".to_string())
    } else {
        Ok(a / b)
    }
}
```

调用的时候可以用 `match` 进行匹配：

```rust
match divide(10, 2) {
    Ok(v) => println!("结果是 {}", v),
    Err(e) => println!("错误: {}", e),
}
```

- 如果`divide(10, 2)`的返回值是`Ok()`变体，则携带的值就会赋值给v
- 如果`divide(10, 2)`的返回值是`Err()`变体，则携带的错误信息就会赋值给e

这就是最基本的 `Result` 使用方式。

#### 常用方法

和 `Option` 一样，`Result` 也内置了许多常见操作方法，让你不必总是写 `match`。

##### is_ok()

判断`Result`的结果是否成功，返回bool类型

```rust
let r1: Result<i32, &str> = Ok(42);


assert!(r1.is_ok());
```



##### is_err()

判断`Result`的结果是否失败，返回bool类型

```rust
let r2: Result<i32, &str> = Err("出错啦");

assert!(r2.is_err());
```





##### unwrap_or()

成功时取出值，失败时给一个默认值。

```rust
let r1: Result<i32, &str> = Ok(5);
let r2: Result<i32, &str> = Err("失败了");

let v1 = r1.unwrap_or(0); // 得到 5
let v2 = r2.unwrap_or(0); // 出错时取默认值 0

println!("v1={}, v2={}", v1, v2);
```



##### map()

如果是成功，就对里面的 `Ok(T)` 做变换；如果是错误，则保持 `Err(E)` 不变。

```rust
fn double(n: i32) -> i32 {
    n * 2
}

let r: Result<i32, &str> = Ok(7);
let doubled = r.map(double); // Ok(14)
println!("doubled={:?}", doubled);

let e: Result<i32, &str> = Err("错误");
let still_err = e.map(double); // Err("错误")
println!("still_err={:?}", still_err);
```



##### and_then()

常用于链式调用：

1. 如果是 `Ok(T)`，就把 `T` 传递给一个 **返回 `Result` 的函数** 继续处理。
2. 如果是 `Err(E)`，就直接返回 `Err`。

```rust
fn check_even(n: i32) -> Result<i32, String> {
    if n % 2 == 0 {
        Ok(n)
    } else {
        Err("不是偶数".to_string())
    }
}

let r1: Result<i32, &str> = Ok(10);
let res1 = r1.and_then(|n| check_even(n)); 
println!("res1={:?}", res1); // Ok(10)

let r2: Result<i32, &str> = Ok(11);
let res2 = r2.and_then(|n| check_even(n));
println!("res2={:?}", res2); // Err("不是偶数")
```



##### unwrap_or_else()

失败时通过一个函数来生成默认值，比 `unwrap_or` 更灵活。

```rust
fn default_value(err: &str) -> i32 {
    println!("出错: {}", err);
    -1
}

let r: Result<i32, &str> = Err("网络故障");
let v = r.unwrap_or_else(default_value); // 调用 default_value，得到 -1
println!("v={}", v);
```



## 4.?运算符

?运算符：是Rust 中用于错误处理的简洁语法，主要作用是从函数中提前返回错误

- 它可以用在返回 Result或Option 类型的函数中
  - 成功时：解包 `Ok(T)`或 `Some(T)`中的值，程序继续执行 
  - 失败时：提早返回 `Err(E)`或 `None`，错误值会自动转换（若可能）



当一个返回Result的函数中使用了另一个返回`Result`的函数，使用`?`运算符可以减少`match`语句的使用

```rust {9-12}
fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err("除数不能为0".to_string())
    } else {
        Ok(a / b)
    }
}

fn get_divide(a: i32, b: i32) -> Result<i32, String> {
    divide(a, b)?;
    Ok(a / b)
}

fn main() {
    let res = get_divide(500, 100);
    match res {
        Ok(d) => println!("{}", d),
        Err(s) => println!("{}", s),
    }
}
```



