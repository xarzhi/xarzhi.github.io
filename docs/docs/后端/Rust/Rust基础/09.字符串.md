# 字符串

`Rust`的字符串分为两种，原生字符串`str`和集合字符串`String`。不论哪一种，内部存储的都是`utf8`编码序列，也就是说每个字符的大小是不定的。

例如`"你好 Rust"`这个字符串，内存视图如下：

![在这里插入图片描述](https://gitee.com/xarzhi/picture/raw/master/img/4d51526c9e184d5d9489adea2bbacb80.png)

`'你'`和`'好'`两个分别占用了三个字节，而后续的`" Rust"`分别占用一字节。图片中所有数据都是对应字节存储的`UTF-8`编码，其中所有数据都是十六进制。

因此字符串不提供`s[0]`这样的下标访问语法，这种语法是按字节访问的，如果你把一个字符串按照字节访问，如果索引不在`UTF-8`的边界上，就会导致错误。

不论哪一种字符串，都视为动态大小类型来处理，比如说：

```rust
let s: &str = "hello"; // 正确
let s: str = "world";  // 错误
```

字符串字面量往往存储在静态区，而非栈区，因此在函数中想要访问到字面量，必须通过指针。

以上代码中，第一行使用`&str`获取胖指针，它是正确的，这是动态大小类型的最常见处理方案。但是第二行直接用`str`接受字符串，这是非法的，因为编译器无法确认字符串的长度。

有人可能就问了，为什么`str`是动态大小类型？定义的时候不是已知每一个字符，自然就知道整个字符串所需要的空间了吗？没错，对于一个字面量确实是可以知道其所需的空间大小的，但是问题在于`str`这个类型本身大小不确定。

比如说数组，它的类型是`[T; N]`，它的大小是体现在类型上的，不同长度的数组有自己单独的类型，就视为这个类型是一个静态大小类型。比如说`[1, 2, 3]` 和`[1, 2]`是不同的类型，它们的长度分别是`12 byte`和`8 byte`。

但是对于一个字符串，不论是`"hello"`还是`"rust"`，它们的类型都是`str`，但是同一个类型`str`却可能是`4 byte`或者`5 byte`。那么这个`str`从类型上来说就是一个动态大小类型，必须通过指针来访问。

除了`str`把字符串放在静态区，也可以使用`String`把字符串放在堆区。

```rust
let s = String::from("hello");
```

此时的`s`就是一个`String`类型的字符串，它的实体放在了堆区，当`s`变量销毁，触发`RAII`机制把堆区的字符串一起回收。

在`String`中，存储三部分内容：

1. `ptr`：指向堆区的指针
2. `len`：字符串的长度
3. `capacity`：堆区目前已分配的容量

前两个之前在胖指针中已经了解过了，`capacity`是什么？

在操作系统中，申请分配一块堆内存是需要额外成本的，因此如果每次增长字符串都要扩容的话，效率就会变得很低。所以程序往往会选择预先申请比自己所需内存更大的内存，这样就可以减少申请内存的此处。目前已申请的可用内存就是`capacity`。

示例：

```rust
let mut s = String::new();
for _ in 0..100 {
    s.push('x');
    if s.len() == s.capacity() {
        println!("len: {}, cap: {}", s.len(), s.capacity());
    }
}
```

以上代码创建了一个`String`，通过循环往里面动态添加一百个`x`字符。每次添加完字符后检查`len`和`capacity`，如果相等就进行一次输出。

结果：

```rust
len: 8, cap: 8
len: 16, cap: 16
len: 32, cap: 32
len: 64, cap: 64
```

可以看到，一开始`capacity`为`8`，后面每次扩容都会把当前的`capacity * 2`，一百个字符最后只需要四次扩容，减少了堆区内存的申请次数。