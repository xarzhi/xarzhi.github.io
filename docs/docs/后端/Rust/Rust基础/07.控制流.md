# 控制流

## 1.条件语句

### 1.1 if...else...

`if` 表达式允许根据条件执行不同的代码分支。你提供一个条件并表示 

- 如果条件满足，运行这段代码
- 如果条件不满足，不运行这段代码。

```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```

所有的 `if` 表达式都以 `if` 关键字开头，其后跟一个条件。在这个例子中，条件检查变量 `number` 的值是否小于 5。在条件为真时希望执行的代码块位于紧跟条件之后的大括号中。`if` 表达式中与条件关联的代码块有时被叫做 *arms*

也可以包含一个可选的 `else` 表达式来提供一个在条件为假时应当执行的代码块，这里我们就这么做了。如果不提供 `else` 表达式并且条件为假时，程序会直接忽略 `if` 代码块并继续执行下面的代码。



:::warning

rust的条件语句中没有隐士转换， **必须** 是 `bool` 值。如果条件不是 `bool` 值，我们将得到一个错误。例如，尝试运行以下代码：

```rust
fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}
```

:::





### 1.2 else if

if..else条件语句只适用于最多两个条件，若某些场景有更多的条件，可以使用else if

比如在一个成绩单中，90-100是优秀，70-90是良好，60-70是及格，60分以下是不及格，可以用以下代码表示

```rust
use std::io;
fn main() {
    let mut grade = String::new();
    io::stdin().read_line(&mut grade).expect("无法读取行");

    let grade: u32 = grade.trim().parse().expect("Please type a number!");
    if grade > 90 && grade < 100 {
        println!("优秀");
    } else if grade > 70 && grade < 90 {
        println!("良好");
    } else if grade > 60 && grade < 70 {
        println!("及格");
    } else {
        println!("不及格");
    }
}
```

运行结果如下

![image-20251202133358204](https://gitee.com/xarzhi/picture/raw/master/img/image-20251202133358204.png)



### 1.3 在let中使用if

因为 `if` 是一个表达式，我们可以在 `let` 语句的右侧使用它

```rust
fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!("The value of number is: {}", number);
}
```

以上示例将 `if` 表达式的返回值赋给变量`number`

`number` 变量将会绑定到表示 `if` 表达式结果的值上。运行这段代码看看会出现什么：

![image-20251202133547864](https://gitee.com/xarzhi/picture/raw/master/img/image-20251202133547864.png)



:::tip

记住，**代码块的值是其最后一个表达式的值**，而数字本身就是一个表达式。

整个 `if` 表达式的值取决于哪个代码块被执行。这意味着 **if 的每个分支的可能的返回值都必须是相同类型**；

上面示例中，`if` 分支和 `else` 分支的结果都是 `i32` 整型。如果它们的类型不匹配，如下面这个例子，则会出现一个错误：

```rust
fn main() {
    let condition = true;

    let number = if condition {
        5
    } else {
        "six"
    };

    println!("The value of number is: {}", number);
}

```

![image-20251202133826161](https://gitee.com/xarzhi/picture/raw/master/img/image-20251202133826161.png)

`if` 代码块中的表达式返回一个整数，而 `else` 代码块中的表达式返回一个字符串。这不可行，因为变量必须只有一个类型。Rust 需要在编译时就确切的知道 `number` 变量的类型，这样它就可以在编译时验证在每处使用的 `number` 变量的类型是有效的。Rust 并不能够在 `number` 的类型只能在运行时确定的情况下工作；这样会使编译器变得更复杂而且只能为代码提供更少的保障，因为它不得不记录所有变量的多种可能的类型。

:::





## 2.循环

多次执行同一段代码是很常用的，Rust 为此提供了多种 **循环**（*loops*）。一个循环执行循环体中的代码直到结尾并紧接着回到开头继续执行。

Rust 有三种循环：`loop`、`while` 和 `for`。

### 2.1 loop循环

`loop` 关键字告诉 Rust 一遍又一遍地执行一段代码直到你明确要求停止。

```rust
fn main() {
    loop {
        println!("again!");
    }
}
```

当运行这个程序时，我们会看到连续的反复打印 `again!`，直到我们手动停止程序。大部分终端都支持一个快捷键，ctrl-c，来终止一个陷入无限循环的程序。尝试一下：

```bash
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29 secs
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
```

符号 `^C` 代表你在这按下了ctrl-c。在 `^C` 之后你可能看到也可能看不到 `again!` ，这取决于在接收到终止信号时代码执行到了循环的何处。

幸运的是，Rust 提供了另一种更可靠的退出循环的方式。可以使用 `break` 关键字来告诉程序何时停止循环，不管是`loop`、`while` 和 `for`，都可以使用break关键字来终止循环。



#### 2.1.1 从循环返回

`loop` 的一个用例是重试可能会失败的操作，比如检查线程是否完成了任务。然而你可能会需要将操作的结果传递给其它的代码。如果将返回值加入你用来停止循环的 `break` 表达式，它会被停止的循环返回：

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
```

在循环之前，我们声明了一个名为 `counter` 的变量并初始化为 `0`。接着声明了一个名为 `result` 来存放循环的返回值。在循环的每一次迭代中，我们将 `counter` 变量加 `1`，接着检查计数是否等于 `10`。当相等时，使用 `break` 关键字返回值 `counter * 2`。循环之后，我们通过分号结束赋值给 `result` 的语句。最后打印出 `result` 的值，也就是 20。



### 2.2 while循环

在程序中计算循环的条件也很常见。当条件为真，执行循环。当条件不再为真，调用 `break` 停止循环。这个循环类型可以通过组合 `loop`、`if`、`else` 和 `break` 来实现；如果你喜欢的话，现在就可以在程序中试试。

然而，这个模式太常用了，Rust 为此内置了一个语言结构，它被称为 `while` 循环。下例使用了 `while`：程序循环三次，每次数字都减一。接着，在循环结束后，打印出另一个信息并退出。

```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number = number - 1;
    }

    println!("LIFTOFF!!!");
}
```

当条件为真时，使用 `while` 循环运行代码

这种结构消除了很多使用 `loop`、`if`、`else` 和 `break` 时所必须的嵌套，这样更加清晰。当条件为真就执行，否则退出循环。



### 2.3 for循环

for循环通常用于遍历一些数据，如下是一个使用for循环遍历数组的示例

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("the value is: {}", element);
    }
}
```

element是一个自定义的名字，相当于给当前迭代项取的一个名字，`iter()`是数组中的迭代器方法，返回一个迭代器方便遍历

for循环遍历数字，可以用`min..max`来表示`[min,max)`范围内的数字，注意不包含max

```rust
fn main() {
    for i in 1..6{
        println!("the number is: {}", i);
    }
}
```

![image-20251202151843370](https://gitee.com/xarzhi/picture/raw/master/img/image-20251202151843370.png)



`for` 循环的安全性和简洁性使得它成为 Rust 中使用最多的循环结构。即使是在想要循环执行代码特定次数时，例如示例 3-3 中使用 `while` 循环的倒计时例子，大部分 Rustacean 也会使用 `for` 循环。这么做的方式是使用 `Range`，它是标准库提供的类型，用来生成从一个数字开始到另一个数字之前结束的所有数字的序列

下面是一个使用 `for` 循环来倒计时的例子，它还使用了一个我们还未讲到的方法，`rev`，用来反转 range：

```rust
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
```
