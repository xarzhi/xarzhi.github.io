# Result

`Result<T, E>`也是一个特殊的枚举，用来表达一个结果**可能成功，也可能失败**。

Result在标准库中的定义如下：

```rust
pub enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

泛型参数

- T：当结果为Ok时，返回的值的类型
- E：当结果为Err时，错误信息的类型

它有两个变体：

- `Ok(T)` 表示操作成功，携带一个结果值 `T`。
- `Err(E)` 表示操作失败，携带一个错误信息 `E`。



## 1.基本使用

`Result<T, E>` 枚举被包含在了 [`prelude`](https://course.rs/appendix/prelude.html)（**prelude 属于 Rust 标准库，Rust 会将最常用的类型、函数等提前引入其中，省得我们再手动引入**）之中，你不需要将其显式引入作用域。

另外，它的成员 `Ok` 和 `Err` 也是如此，无需使用 `Option::` 前缀就可直接使用 `Some` 和 `None`。

比如下面一段代码

```rust
let o: Result<i32, &str> = Result::Ok(123);
let e: Result<i32, &str> = Result::Err("Failed to read file");
```

完全可以去掉`Option::`，然后使用下面的方式

```rust
let o: Result<i32, &str> = Ok(123);
let e: Result<i32, &str> = Err("Failed to read file");
```





Result常用于一个io操作函数的返回值

```rust
fn read_file(path: &str) -> Result<String, &str> {
    match std::fs::read_to_string(path) {
        Ok(s) => Ok(s),
        Err(_) => Err("Failed to read file"),
    }
}
```



:::warning 注意

不管是定义一个Ok变量，还是Err变量，都需要显示声明泛型

```rust
let o: Result<i32, &str> = Result::Ok(123);
let e: Result<i32, &str> = Err("Failed to read file");
```

:::





## 2.模式匹配

对于一个Result，使用模式匹配来获取其结果是相当经典的

```rust
let o: Result<i32, &str> = Ok(123);

match o {
    Ok(value) => {
        println!("{}", value);
    }
    Err(err) => {
        println!("{}", err);
    }
}
```

- 若Result的结果为Ok，那么在match中，Ok包含的值就会被赋值给参数value
- 若Result的结果为Err，那么在match中，Err包含的值就会被赋值给参数err



### 2.1 if let

`if let`是`match`的语法糖，简化`Option`和`Result`的`match`语句先看如下代码

当我们只关注`Result`成功的结果，而不想去处理失败的结果时，使用if let是个好选择

```rust
let o: Result<i32, &str> = Ok(123);

if let Ok(x) = o {
    println!("{}", x);
}
```

`if let`语句将先判断变量是否是`Ok`变体，如果是，则把这个变量的值赋值给`Ok`的参数





### 2.4 ?运算符

`?`运算符：是Rust 中用于错误处理的简洁语法，主要作用是从函数中提前返回错误

- 它可以用在返回 Result或Option 类型的函数中
  - 成功时：解包 `Ok(T)`或 `Some(T)`中的值，程序继续执行 
  - 失败时：提早返回 `Err(E)`或 `None`，错误值会自动转换（若可能）

当一个返回Result的函数中使用了另一个返回`Result`的函数，使用`?`运算符可以减少`match`语句的使用

```rust {9-12}
fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err("除数不能为0".to_string())
    } else {
        Ok(a / b)
    }
}

fn get_divide(a: i32, b: i32) -> Result<i32, String> {
    divide(a, b)?;
    Ok(a / b)
}

fn main() {
    let res = get_divide(500, 100);
    match res {
        Ok(d) => println!("{}", d),
        Err(s) => println!("{}", s),
    }
}
```



## 3.方法

### impl<T, E> Result<T, E>

#### is_ok

#### is_ok_and

#### is_err

#### is_err_and

#### ok

#### err

#### as_ref

#### as_mut

#### map

#### map_or

#### map_or_else

#### map_err

#### inspect

#### inspect_err

#### as_deref

#### as_deref_mut

#### iter

#### iter_mut

#### expect

#### unwrap

#### unwrap_or_default

#### expext_err

#### upwrap_err

#### into_ok

#### into_err

#### and

#### and_then

#### or

#### or_else

#### unwrap_or

#### unwrap_or_else

#### unwrap_or_unchecked

#### unwrap_err_unchecked



### impl<T, E> Result<&T, E>

#### copied



#### cloned



### impl<T, E> Result<&mut T, E>

#### copied



#### cloned



### impl<T, E> Result<Option\<T>, E>

#### transpose



### impl<T, E> Result<Result<T, E>, E>

#### flatten







## 4.特征实现

