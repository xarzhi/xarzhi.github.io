# 结构体

*`struct`*，或者 *structure*，是一个自定义数据类型，允许你命名和包装多个相关的值，从而形成一个有意义的组合。如果你熟悉一门面向对象语言，*struct* 就像对象中的数据属性。

## 1.定义结构体

使用`struct`关键字来定义一个结构体，如下所示

- `struct`关键字后面跟上这个结构体的名字
- 接着在大括号中使用 `key: value` 键-值对的形式提供字段，其中 key 是字段的名字，value 是需要存储在字段中的数据值

```rust
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
```



## 2.使用结构体

### 2.1 创建结构体实例

想要使用结构体，需要先创建结构体实例，一个结构体可以创建多个实例

创建一个实例需要以结构体的名字开头，接着在大括号中使用 `key: value` 键-值对的形式提供字段，其中 key 是字段的名字，value 是需要存储在字段中的数据值。**实例中字段的顺序不需要和它们在结构体中声明的顺序一致**。

```rust
let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};
```

结构体的定义就像一个类型的通用模板，而实例则会在这个模板中放入特定数据来创建这个类型的值。



### 2.2 访问实例成员

可以使用`实例.key`来访问结构体实例中的某一项的值

```rust {14-17}
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
fn main() {
    let user = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
    println!("{}",user.email);              // "someone@example.com"
    println!("{}",user.username);           // "someusername123"
    println!("{}",user.active);             // true
    println!("{}",user.sign_in_count);      // 1
}
```





### 2.3 修改实例成员值

想要实例成员的值可被修改，需要在实例成员时使用`mut`关键字

**注意整个实例必须是可变的**；Rust 并不允许只将某个字段标记为可变。

```rust {15,17}
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
fn main() {
    let mut user = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
    
    user.email=String::from("123@qq.com");

    println!("{}",user.email);              // "123@qq.com"
    println!("{}",user.username);           // "someusername123"
    println!("{}",user.active);             // true
    println!("{}",user.sign_in_count);      // 1
}
```



## 3.函数返回结构体

同其他任何表达式一样，我们可以在函数体的最后一个表达式中构造一个结构体的新实例，来隐式地返回这个实例。

```rust {7-14,16-18}
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
fn main() {
    let email = String::from("123@qq.com");
    let username = String::from("xarzhi");
    let user = build_user(email, username);

    
    println!("{}",user.email);              // "123@qq.com"
    println!("{}",user.username);           // "xarzhi"
    println!("{}",user.active);             // true
    println!("{}",user.sign_in_count);      // 1
}

```



### 3.1 变量与字段同名

当**函数参数名与字段名都完全相同**，我们可以使用 **字段初始化简写语法**（*field init shorthand*）来重写 `build_user`，这样其行为与之前完全相同，不过无需重复 `email` 和 `username` 了

```rust {9-10}
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
fn main() {
    let email = String::from("123@qq.com");
    let username = String::from("xarzhi");
    let user = build_user(email, username);

    
    println!("{}",user.email);              // "123@qq.com"
    println!("{}",user.username);           // "xarzhi"
    println!("{}",user.active);             // true
    println!("{}",user.sign_in_count);      // 1
}
```





## 4.从其他实例创建实例

如果已经有一个实例，我们想再创建一个新实例，新实例中的部分成员值和其他实例的值一样，可以直接使用其他实例的值

```rust {11,12}
let mut user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};

let mut user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    active: user1.active,
    sign_in_count: user1.sign_in_count,
};
```

### 4.1 结构体更新语法

我们可以通过更少的代码来达到相同的效果，`..` 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值。

```rust {3}
let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    ..user1
};
```





## 5. 元组结构体

元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型。当你想给整个元组取一个名字，并使元组成为与其他元组不同的类型时，元组结构体是很有用的，这时像常规结构体那样为每个字段命名就显得多余和形式化了。

要定义元组结构体，以 `struct` 关键字和结构体名开头并后跟元组中的类型

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```

注意 `black` 和 `origin` 值的类型不同，因为它们是不同的元组结构体的实例。

你定义的每一个结构体有其自己的类型，即使结构体中的字段有着相同的类型。



### 5.1 类单元结构体

我们也可以定义一个没有任何字段的结构体！它们被称为 **类单元结构体**（*unit-like structs*）因为它们类似于 `()`，即 unit 类型。类单元结构体常常在你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用，trait在后面介绍。



:::tip

**结构体数据的所有权**

在上面 结构体的定义中，我们使用了自身拥有所有权的 `String` 类型而不是 `&str` 字符串 slice 类型。这是一个有意而为之的选择，因为我们想要这个结构体拥有它所有的数据，为此只要整个结构体是有效的话其数据也是有效的。

可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上 **生命周期**（*lifetimes*），这是一个第十章会讨论的 Rust 功能。生命周期确保结构体引用的数据有效性跟结构体本身保持一致。如果你尝试在结构体中存储一个引用而不指定生命周期将是无效的，比如这样：

```rust
struct User {
    username: &str,
    email: &str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: "someone@example.com",
        username: "someusername123",
        active: true,
        sign_in_count: 1,
    };
}
```

编译器会抱怨它需要生命周期标识符：

```text
error[E0106]: missing lifetime specifier
 -->
  |
2 |     username: &str,
  |               ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
 -->
  |
3 |     email: &str,
  |            ^ expected lifetime parameter
```

第十章会讲到如何修复这个问题以便在结构体中存储引用，不过现在，我们会使用像 `String` 这类拥有所有权的类型来替代 `&str` 这样的引用以修正这个错误。

:::





## 6.增强结构体打印

有如下示例，我们想打印结构体的内容

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!("rect1 is {}", rect1);
}
```

这样打印会报错：`error[E0277]: Rectangle doesn't implement std::fmt::Display`

`println!` 宏能处理很多类型的格式，不过，`{}` 默认告诉 `println!` 使用被称为 `Display` 的格式：意在提供给直接终端用户查看的输出。目前为止见过的基本类型都默认实现了 `Display`，因为它就是向用户展示 `1` 或其他任何基本类型的唯一方式。不过对于结构体，`println!` 应该用来输出的格式是不明确的，因为这有更多显示的可能性：是否需要逗号？需要打印出大括号吗？所有字段都应该显示吗？由于这种不确定性，Rust 不会尝试猜测我们的意图，所以结构体并没有提供一个 `Display` 实现。

想要打印完整的结构体，需要把 `println!` 宏中的`{}`换成`{:?}`，然后在结构体声明的上面加上`#[derive(Debug)]`注解

```rust {1,10}
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!("rect1 is  {:?}", rect1);
}
```

打印结果如下

![image-20251204194721737](https://gitee.com/xarzhi/picture/raw/master/img/image-20251204194721737.png)



如果想要更格式化的输入，可以把`println!` 宏中的`{:?}`换成`{:#?}`

```rust {10}
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!("rect1 is  {:#?}", rect1);
}
```

打印结果如下，这样看起来就方便许多了

![image-20251204194958101](https://gitee.com/xarzhi/picture/raw/master/img/image-20251204194958101.png)





## 7.方法语法

**方法** 与函数类似：它们使用 `fn` 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。

不过方法与函数是不同的，因为它们在结构体的上下文中被定义（或者是枚举或 trait 对象的上下文，将分别在第六章和第十七章讲解），并且它们第一个参数总是 `self`，它代表调用该方法的结构体实例。



### 7.1 定义与使用方法

定义方法，需要使用 `impl` 块中定义，语法如下

- 使用`impl`关键字，后面跟着结构体的名字，再加上`{}`块
- 在方法的签名中，第一个参数必须是`self`，也就是实例本身
- 想要使用实例中的结构体方法，需要使用`实例.方法()`的语法

```rust {7-11}
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

在 `area` 的签名中，使用 `&self` 来替代 `rectangle: &Rectangle`，因为该方法位于 `impl Rectangle` 上下文中所以 Rust 知道 `self` 的类型是 `Rectangle`。注意仍然需要在 `self` 前面加上 `&`，就像 `&Rectangle` 一样。方法可以选择获取 `self` 的所有权，或者像我们这里一样不可变地借用 `self`，或者可变地借用 `self`，就跟其他参数一样。

这里选择 `&self` 的理由跟在函数版本中使用 `&Rectangle` 是相同的：我们并不想获取所有权，只希望能够读取结构体中的数据，而不是写入。

如果想要在方法中改变调用方法的实例，需要将第一个参数改为 `&mut self`。通过仅仅使用 `self` 作为第一个参数来使方法获取实例的所有权是很少见的；这种技术通常用在当方法将 `self` 转换成别的实例的时候，这时我们想要防止调用者在转换之后使用原始的实例。

使用方法替代函数，除了可使用方法语法和不需要在每个函数签名中重复 `self` 的类型之外，其主要好处在于组织性。我们将某个类型实例能做的所有事情都一起放入 `impl` 块中，而不是让将来的用户在我们的库中到处寻找 `Rectangle` 的功能。



### 7.2 更多参数的方法

- 方法的第一个参数必须是`self`，若想添加其他参数，就在`self`后面依次增加
- 在调用方法时，第一个实参就是函数签名的第二个参数，依此类推
- 若想在方法中修改实例的成员值，需要使用`mut`关键字定义`self`

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn change_width_and_height(&mut self, width: u32, height: u32) {
        self.width = width;
        self.height = height;
    }
}

fn main() {
    let mut rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    rect1.change_width_and_height(30, 50);
}

```



## 8.关联函数



`impl` 块的另一个有用的功能是：允许在 `impl` 块中定义 **不** 以 `self` 作为参数的函数。

这被称为 **关联函数**（*associated functions*），因为它们与结构体相关联。它们仍是函数而不是方法，因为它们并不作用于一个结构体的实例。你已经使用过 `String::from` 关联函数了。

- **关联函数经常被用作返回一个结构体新实例的构造函数**。比如我们可以创建一个关联函数new()，接受宽和高作为参数，然后返回一个Rectangle实例，这样使用new()函数创建实例会更方便些
- 使用结构体名和 `::` 语法来调用这个关联函数

```rust
impl Rectangle {
    fn new(width: u32, height: u32) -> Rectangle {
        Rectangle { width, height }
    }
}

fn main() {
    let rect = Rectangle::new(30, 50);

    println!("宽{}，高{}", rect.width, rect.height);
}
```







## 9.多个impl块

每个结构体都允许拥有多个 `impl` 块。每个`impl`块也可以定义多个方法或关联函数

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

// 用于计算矩形的面积和周长
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn perimeter(&self) -> u32 {
        self.width * 2 + self.height * 2
    }
}

// 用于创建实例
impl Rectangle {
    fn new(width: u32, height: u32) -> Rectangle {
        Rectangle { width, height }
    }
}

fn main() {
    let rect = Rectangle::new(30, 50);

    println!("面积：{}，周长：{}", rect.area(), rect.perimeter());
}

```

:::tip

方法和关联函数也可以放在同一个`impl`块中，如下

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn perimeter(&self) -> u32 {
        self.width * 2 + self.height * 2
    }
    
    fn new(width: u32, height: u32) -> Rectangle {
        Rectangle { width, height }
    }
}
```

但是官方不推荐这么做，把方法和关联函数分类放更有利于阅读

:::

