# 算法基础

## 1.函数对象

### 1.1 概念

函数调用操作符，也就是小括号`()`，重载了此操作符的类，称之为**函数对象**，函数对象是行为类似于函数的对象，也叫**仿函数**（functor），**函数对象使类可以像函数那样调用**

注意：

- **函数对象是个类，不是一个函数**
- 函数对象重载了函数调用操作符，使类可以像函数那样调用

在一个类中，当我们重载`()`操作符时，若重载的`operator()`需要一个参数，则称之为**一元仿函数**，若重载的`operator()`需要两个参数，则称之为**二元仿函数**

```c++ {11-13,18}
#include <iostream>
#include <map>
using namespace std;

class MyPrint {
public:
    int num;
    MyPrint() {
        num = 0;
    }
    void operator()(int num) {
        this->num = num;
    }
};

int main() {
    MyPrint mp;
    mp(1000);

    cout << mp.num << endl;
    return 0;
}
```



### 1.2 谓语

如果一个仿函数中**重载()的函数返回类型为bool类型**，那么这样的仿函数就是**谓语**



### 1.3 内置仿函数

STL内建了一些函数对象。分为：算数类函数对象，关系运算类函数对象，逻辑运算类仿函数。这些仿函数所产生的对象，用法和一般函数完全相同，当然我们还可以产生无名的临时对象来履行函数功能。使用内建函数对象，需要引入头文件`#include <functional>`。

#### 1.3.1 算数类

除了`negate`是一元运算，其他都是二元运算。

```c++
template<class T> T plus <T>		// 加法仿函数
template<class T> T minus <T>		// 减法仿函数
template<class T> T multiplies <T>	// 乘法仿函数
template<class T> T divides <T>		// 除法仿函数
template<class T> T modulus <T>		// 取模仿函数
template<class T> T negate <T>		// 取反仿函数
```

使用实例

```c++
#include <iostream>
#include <functional>
using namespace std;

int main() {
    plus<int> p;
    cout << p(10, 20)<< endl;       	// 30

    minus<int> min;
    cout << min(10,4) << endl;       	// 6

    multiplies<int> multip;
    cout << multip(10,5) << endl;       // 50

    divides<int> d;
    cout << d(10, 5) << endl;       	// 2

    modulus<int> mo;
    cout << mo(10, 3) << endl;       	// 1

    negate<int> ne;
    cout << ne(10) << endl;       		// -10

    return 0;
}
```



#### 1.3.2 关系运算类

每一种都是二元运算。

```c++
template<class T> bool equal_to<T>			// 等于
template<class T> bool not_equal_to<T>		// 不等于
template<class T> bool greater<T>			// 大于
template<class T> bool greater_equal<T>		// 大于等于
template<class T> bool less<T>				// 小于
template<class T> bool less_equal<T>		// 小于等于
```

使用实例

```c++
#include <iostream>
#include <functional>
using namespace std;

int main() {
	equal_to<int> equal;
	cout << equal(10, 10) << endl;		// 1
	cout << equal(10, 9) << endl;       // 0

	not_equal_to<int> not_equal;
	cout << not_equal(10, 10) << endl;  // 0
	cout << not_equal(10, 9) << endl;   // 1

	greater<int> greater;
	cout << greater(9, 10) << endl;       // 0
	cout << greater(10, 10) << endl;  // 0
	cout << greater(10, 9) << endl;       // 1

	greater_equal<int> gequal;
	cout << gequal(10, 10) << endl;  // 1
	cout << gequal(10, 9) << endl;       // 1

	less<int> less;
	cout << less(10, 10) << endl;  // 0
	cout << less(9, 10) << endl;       // 1

	less_equal<int> less_e;
	cout << less_e(10, 10) << endl;  // 1
	cout << less_e(9, 10) << endl;       // 1

	return 0;
}
```



#### 1.3.3 逻辑运算类

logical_not为一元运算，其余为二元运算

```c++
template<class T>bool logical_and<T>	//逻辑与
template<class T>bool logical_or<T>		//逻辑或
template<class T>bool logical_not<T>	//逻辑非
```

使用实例

```c++
#include <iostream>
#include <functional>
using namespace std;

int main() {
	logical_and<int> la;
	cout << la(10 < 9, 9 < 10) << endl;  // 0

	logical_or<int> lo;
	cout << la(10 < 9, 9 < 10) << endl;  // 1

	logical_not<int> ln;
	cout << ln(10 < 9) << endl;  // 1

	return 0;
}
```





## 2.算法

算法主要是由头文件组成。
是所有STL头文件中最大的一个，其中常用的功能涉及到比较，交换，查找，遍历，复制，修改，反转，排序，合并等..
体积很小，只包括在几个序列容器上进行的简单运算的模板函数。
定义了一些模板类，用以声明函数对象。

使用算法需要引入头文件`algorithm`

```c++
#include <algorithm>
```



### 2.1 常用遍历算法

#### 2.1.1 for_each()

```c++
/*
    遍历算法遍历容器元素
    @param beg开始选代器
    @param end结束选代器
    @param _ca11back 函数回调或者函数对象
    @return 函数对象
*/
for_each(iterator beg，iterator end,_callback)
```

使用实例

```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

class Print {
public:
	void operator()(int i) {
		cout << i << "，";
	}
};

int main() {
	
	vector<int> v = { 1,2,3,4,5,6,7,8,9,10 };

	for_each(v.begin(), v.end(), Print());

	return 0;
}
```

第三个参数也可以传一个函数的引用，注意不能加`()`，不然就变成了函数的调用

```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

void print(int i) {
	cout << i << "，";
}

int main() {
	
	vector<int> v = { 1,2,3,4,5,6,7,8,9,10 };

	for_each(v.begin(), v.end(), print);

	return 0;
}
```



#### 2.1.2 transform()

transform算法**将指定容器区间元素搬运到另一容器中**
注意：**transform不会给目标容器分配内存，所以需要我们提前分配好内存**

```c++
/*
    @param beg1 源容器开始迭代器
    @param end1 源容器结束迭代器
    @param beg2 目标容器开始迭代器
    @param_callback 回调函数或者函数对象
    @return 返回目标容器迭代器
*/
transform(iterator beg1, iterator end1, iterator beg2, _callback);
```

使用实例

```c++
```

