# JS基础语法

一个不错的网站：[javascript.info](https://zh.javascript.info/)

## 一、JS（JavaScript）简介

### 是什么？

JavaScript（简称“JS”） 是一种具有函数优先的轻量级、弱类型，解释型或即时编译型的编程语言。JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式、声明式、函数式编程范式。

* 脚本语言

  - 不用编译直接执行。 

  - 无法独立执行。 

  - 必须依赖其他的程序(浏览器)才能执行。

### 能干嘛？

web标准----网页的组成部分

```
结构   HTML   从语义的角度，描述页面的结构 
表现   CSS       从审美的角度，美化页面 
行为   JavaScript   从交互的角度，提升用户体验
```

*   HTML+CSS： 用来实现网页的结构搭建和样式修饰

*   JS实战应用：用于实现网页特效&交互

### 组成

JavaScript 由三个部分组成**(ECMA、BOM、DOM)**

**ECMAScript(标准/规则)**：描述了JS语言的语法和基本对象，规定JS基础语法和规则 

**BOM(浏览器对象模型)**：描述处理浏览器的方法和接口，让js有能力操作浏览器 ​ 

**DOM(文档对象模型)**：描述与网页元素内容交互的方法和接口，让js有能力操作网页

## 二、JavaScript初体验

我们的JS程序是运行在浏览器中的，但是JS代码却又无法单独的运行在浏览器中，所以我们需要借助HTML文件来实现。

### 引用JavaScript

对于JS程序的引入我们分为三种方式：

*   1、内部 （学习中使用比较多）

*   2、外部 （工作中推荐使用）

*   3、内联 （一般不推荐使用）

#### 内部引入

在页面中使用一对script标签，将JS代码写在script标签内部。

```html
<script> alert("hello world!!");</script>
```

*   注：script标签 可以放在 head中 也可以放在 body中

#### 外部引入

使用script标签的src属性引入一个外部的以.js为扩展名的文件，在.js文件中直接编写JS代码即可。

HTML文件中书写：

```html
<script src="路径及文件名.js"></script> 
```

注意：使用script标签引入外部js文件时，当前script标签内部不能再书写js代码

*   注：script标签 可以放在 head中 也可以放在 body中，并且一个页面可以引入多个 js文件。

##### defer和async

当我们使用`<script></script>` 标签引入js文件时，可以通过`defer`和`async`改变js文件的加载时机

- defer：整个页面正常渲染结束，才会执行此js文件的代码，**渲染完再执行**
- async：一旦此js文件下载完，就会执行，**下载完就执行**

```html
<script src="./js" defer></script>
<script src="./js" async></script>
```

如果有多个defer脚本，会按照他们在页面出现的顺序加载

而多个async脚本则不能保证加载顺序，因为一旦有下载完毕的async脚本就会立即执行

defer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）



#### 内联使用

将JS代码直接写在标签内部，作为标签的属性值出现。

```html
<!-- 正常元素书写 --> 
<div onclick='alert("hello world!!")'>点击试试</div> 
<!-- a标签书写 --> 
<a href='javascript:alert("hello world!!")'>点击试试</a>
<!-- 注意：需要点击标签才能出发代码执行 -->
```



### JS中常用的输出语法

#### alert

作用：alert会弹出一个警告框 

语法：alert("内容") 

```js
alert("hello world");
```

#### document.write

作用：网页中写入内容(可以识别标签)

语法：document.write("内容") 

```js
document.write("hello world"); 
document.write("<h1>hello world</h1>");
```

#### console

| 方法             | 描述                                                         |
| :--------------- | :----------------------------------------------------------- |
| assert()         | 如果断言为 false，则在信息到控制台输出错误信息。             |
| clear()          | 清除控制台上的信息。                                         |
| count()          | 记录 count() 调用次数，一般用于计数。                        |
| error()          | 输出错误信息到控制台                                         |
| group()          | 在控制台创建一个信息分组。 一个完整的信息分组以 console.group() 开始，console.groupEnd() 结束 |
| groupCollapsed() | 在控制台创建一个信息分组。 类似 console.group() ，但它默认是折叠的。 |
| groupEnd()       | 设置当前信息分组结束                                         |
| info()           | 控制台输出一条信息                                           |
| **log()**        | 控制台输出一条信息                                           |
| table()          | 以表格形式显示数据                                           |
| time()           | 计时器，开始计时间，与 timeEnd() 联合使用，用于算出一个操作所花费的准确时间。 |
| timeEnd()        | 计时结束                                                     |
| trace()          | 显示当前执行的代码在堆栈中的调用路径。                       |
| warn()           | 输出警告信息，信息最前面加一个黄色三角，表示警告             |

#### prompt

作用：prompt:弹出一个输入框，可以输入值

语法：var data = prompt("内容") 

返回：返回用户输入的内容，通过变量接受 var data = prompt("请输入你的真实年龄");



### JS的注释

需求为了便于多人协作开发，加快开发速度，增加代码可读性，要养成写注释的习惯。

语法

```js
// 单行注释

/*  这是多行注释
	中间的所有内容都会被注释
*/
```



## 三、变量

*   通俗来讲变量指的是在程序中保存数据的一个容器。

*   在程序运行过程中其值可以改变的量，是一个数据存储空间的表示，即给内存空间起别名。
*   将数据通过变量进行存储，以便程序随时使用，通俗点来说，变量就是用来存储数据的。
*   所谓变量，就是特定时间用于保存特定值的一个名字而已，并且初始化后可以再次改变的量。
*   ECMAScript 的变量是松散(弱)类型的，所谓松散类型就是可以用来保存任何类型的数据。

### 变量的声明

JS中声明变量必须用 var

常用语法：var 变量名 = 值;

```js
// 先声明后赋值 
// 声明一个变量 
var num; 
// 为该变量赋值 
num = 10; 
// 将数字10赋值给变量num1 
// 同时声明并赋值
// 声明一个变量stuName并为其赋值 
var stuName = 'tom'; 
// 不声明直接赋值
// 将数字20赋值给变量num2 
num2 = 20;
// 不推荐
//一次性声明多个变量并赋值(值不一样时) 
var num1=1,num2=2,num3=3； 
//一次性声明多个变量并赋值(值一样时)
var num1=num2=num3=100； 
// 一次性声明多个变量后赋值 
var num1,num2,num3; num1 = 10; num2 = 20; num3 = 30;
```



### 变量的命名规范

我们可以为每一个变量取不同的名称，这些名称能够很好的帮助我们快速的理解变量里所存的值代表了什么，所以JS对变量的命名有一套严格的规范。

*   变量名也叫：标识符

*   只能由数字、字母、下划线和\$符号组成，但是不能以数字开头

*   不可以使用JS中的关键字和保留字

*   关键字：被JS语言赋予了特殊含义的单词

*   保留字：现在还没有被JS使用，但是将来可能会被使用的单词

注：关键字和保留字比较多不需要立马全部记住，经常查看文档即可。

但是针对 top、new、this、delete需要记住严格区分大小写

我们的推荐：

*   变量名需要见名知意

*   使用驼峰式和下划线式命名法

*   驼峰： myClassName

*   下划线： my\_class\_name

## 四、数据类型

在JS语言中数据类型可以分为两大类：

**基本数据类型**：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol、bigInt

**引用数据类型**：Object

- 可调用/执行对象「函数」：function
- 标准特殊对象：Array、Date、Math、RegExp、Error……
- 非标准特殊对象：Number、String、Boolean……

> 基本数据类型与引用数据类型它们的赋值与取值有区别的。请看下面的代码：

```js
//基本数据类型
var num1 = 10;
var num2 = num1;
num2 = 15;
console.log(num1);  // 10
console.log(num2);  // 15


//引用数据类型	
var arr1 = [1,2,3,4];
var arr2 = arr1;
arr2[2] = 10;
console.log(arr1);   // [1, 2, 10, 4]
console.log(arr2);   //[1, 2, 10, 4]
```

> 通过上面的案例我们可以很清晰的发现基本数据类型num2从num1里面取值，后续对num2的操作不会影响到num1，但是引用数据类型的数组则不同，对arr2的操作也会影响到arr1，这是为什么呢？

> 这一点就要从 **基本数据类型** 和 **引用数据类型** 的在内存中的存储位置来分析了

- 基本数据类型指的是简单的数据段，存储在**栈（stack）**中
- 引用数据类型指的是有多个值构成的对象，存储在**堆（heap）**中。

原始类型：变量赋值，栈开辟内存直接存数据   ->  数据互不影响
对象类型：变量赋值，栈开辟内存，存放堆地址  -> 数据相互影响



### 数据类型的判断

*   我们知道JS中拥有5中基本数据，这几种数据类型我们可以借助一个函数/运算符来达到准确的判断

#### typeof

typeof可以判断基本数据类型的数据类型，但相对于引用数据类型，的出来的结果都是object

对于null，得出的结果式object

```js
let num=111
console.log(typeof(num))
console.log(typeof num)
```

#### Object.prototype.toString.call()

监狱typeof的局限性，想要精准判断数据类型，此方法式不二之选

```js
/**
 * 
 * @param {any} val 需要判断的数据
 * @returns  返回精确的数据类新
 */

function getType(val){
   return Object.prototype.toString.call(val).slice(8,-1)
}
```



## 五、运算符

### 算数运算符

| 运算符 | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| +      | 加法                                                         |
| -      | 减法                                                         |
| *      | 乘法                                                         |
| /      | 除法                                                         |
| %      | 取模（余数）                                                 |
| ++     | 自增                                                         |
| --     | 自减                                                         |
| <<     | 左移,将第一个操作数向左移动指定位数，左边超出的位数将会被清除，右边将会补零。 |
| >>     | 右移，将一个操作数的二进制表示形式向右移动指定位数，该操作数可以是数值或者 BigInt 类型。<br/>右边移出位被丢弃，左边移出的空位补符号位（最左边那位）。<br/>该操作也称为“符号位传播右移”（sign-propagating right shift）或“算术右移”（arithmetic right shift），<br/>因为返回值的符号位与第一个操作数的符号位相同。 |

**左移操作符 (`<<`)** 

```js
const a = 5; // 00000000000000000000000000000101
const b = 2; // 00000000000000000000000000000010

console.log(a << b); // 00000000000000000000000000010100
// Expected output: 20
```

**右移运算符**（**`>>`**）

```js
const a = 5; //  00000000000000000000000000000101
const b = 2; //  00000000000000000000000000000010
const c = -5; //  11111111111111111111111111111011

console.log(a >> b); //  00000000000000000000000000000001
// Expected output: 1

console.log(c >> b); //  11111111111111111111111111111110
// Expected output: -2
```



### 赋值运算符

| 运算符 | 用法  | 等同于 | 描述                                                 |
| :----- | :---- | :----- | ---------------------------------------------------- |
| =      | x=y   |        | 赋值，把右值赋值给左值                               |
| +=     | x+=y  | x=x+y  | 加法赋值，把左值**加**上右值，再赋值给左值           |
| -=     | x-=y  | x=x-y  | 减法赋值，把左值**减**上右值，再赋值给左值           |
| *=     | x*=y  | x=x*y  | 乘法赋值，把左值**乘**上右值，再赋值给左值           |
| /=     | x/=y  | x=x/y  | 除法赋值，把左值**除**上右值，再赋值给左值           |
| %=     | x%=y  | x=x%y  | 取余赋值，把左值**除**上右值，再把**余数**赋值给左值 |
| <<=    | x<<=y | x=x<<y | 左移赋值，把左值**向左移动右值的位数**，再赋值给左值 |
| >>=    | x>>=y | x=x>>y | 右移赋值，把左值**向右移动右值的位数**，再赋值给左值 |

### 比较运算符

| 运算符 | 描述                                               |
| :----- | :------------------------------------------------- |
| ==     | 等于，比较值                                       |
| ===    | 绝对等于，比较值和类型                             |
| !=     | 不等于                                             |
| !==    | 不绝对等于（值和类型有一个不相等，或两个都不相等） |
| >      | 大于                                               |
| <      | 小于                                               |
| >=     | 大于或等于                                         |
| <=     | 小于或等于                                         |

### 逻辑运算符

| 运算符 | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| &&     | 且运算，运算符两边都为`true`才为`true`,否则为`false`，或者左边为`true`则执行右边语句 |
| \|\|   | 或运算，运算符两边有一边为`true`即为`true`,否则为`false`，或者左边为`true`返回左边值，否者返回右边值 |
| \|\|=  | 逻辑或赋值（`x ||= y`）运算仅在 `x` 为`false`时为其赋值。    |
| !      | 取反，`!true`即为`false`                                     |
| ??     | 空值合并，当左侧的操作数为`null`或者`undefined`时，返回其右侧操作数，否则返回左侧操作数。 |
| ??=    | 空赋值运算符，仅在 `x` 是空值（`null` 或 `undefined`）时对其赋值。 |

### 可选链运算符

| 运算符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| ?.     | `?.` 运算符的功能类似于 `.` 链式运算符，<br/>在引用为空 ([nullish](https://developer.mozilla.org/zh-CN/docs/Glossary/Nullish) ) ([`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/null) 或者 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)) 的情况下不会引起错误，<br/>该表达式短路返回值是 `undefined`。与函数调用一起使用时，如果给定的函数不存在，则返回 `undefined`。 |

**语法**

```js
obj.val?.prop
obj.val?.[expr]
obj.func?.(args)
```



### 三元运算符

**语法**

```js
条件 ? 为true触发的逻辑 : 为false触发的逻辑
```



### 一元运算符

| 运算符 | 描述                  |
| ------ | --------------------- |
| num++  | 先执行逻辑，在将num+1 |
| ++num  | 先将num+1，在执行逻辑 |
| num--  | 先执行逻辑，在将num-1 |
| --num  | 先将num-1，在执行逻辑 |

### 位运算符

| 运算符 | 描述 | 例子       | 类似于       | 结果 | 十进制 |
| :----- | :--- | :--------- | :----------- | :--- | :----- |
| &      | AND  | x = 5 & 1  | 0101 & 0001  | 0001 | 1      |
| \|     | OR   | x = 5 \| 1 | 0101 \| 0001 | 0101 | 5      |
| ~      | 取反 | x = ~ 5    | ~0101        | 1010 | -6     |
| ^      | 异或 | x = 5 ^ 1  | 0101 ^ 0001  | 0100 | 4      |
| <<     | 左移 | x = 5 << 1 | 0101 << 1    | 1010 | 10     |
| >>     | 右移 | x = 5 >> 1 | 0101 >> 1    | 0010 | 2      |

### 运算符优先级

| 优先级 | 分类           | 运算符                                          | 结合性     |
| ------ | -------------- | ----------------------------------------------- | ---------- |
| 1      | 后缀运算符     | ( )、[ ]、->                                    | 从左到右   |
| 2      | 单目运算符     | !、*（指针）、& 、++、--、+（正号）、-（负号）  | `从右到左` |
| 3      | 乘法/除法/取余 | *（乘号）、/、%                                 | 从左到右   |
| 4      | 加法/减法      | +、-                                            | 从左到右   |
| 5      | 位移运算符     | <<、>>                                          | 从左到右   |
| 6      | 关系运算符     | <、<=、>、>=                                    | 从左到右   |
| 7      | 相等/不等      | ==、!=                                          | 从左到右   |
| 8      | 按位与         | &                                               | 从左到右   |
| 9      | 按位异或       | ^                                               | 从左到右   |
| 10     | 按位或         | \|                                              | 从左到右   |
| 11     | 逻辑与         | &&                                              | 从左到右   |
| 12     | 逻辑或         | \|\|                                            | 从左到右   |
| 13     | 三目运算符     | ? :                                             | `从右到左` |
| 14     | 赋值运算符     | =、+=、-=、*=、/=、 %=、 >>=、 <<=、&=、^=、\|= | `从右到左` |
| 15     | 逗号运算符     | ,                                               | 从左到右   |

## 六、数据类型的转换

### 强制类型转换---显式转换

#### 转换为string

*   String():将需要被转换的内容放入小括号内部即可


*   toString():直接调用变量的toString()方法，变量不能是空值（null）并且也不能是undefined



#### 转换为number

将得到的数据转换为number类型我们需要以下三个方法：

**Number()**

*   如果内容可以转换成数字，则返回对应的数字（整数或小数）

*   如果内容不可以转换成数字，则返回NaN

*   如果内容为空，则返回0


**parseInt()**

*   将内容转换成整数（直接去掉小数）

*   从第一位开始检查，数字直接转换，直到第一个不是数字的内容就去掉

*   第一位就不是数字的，直接转换为 NaN

*   不认识小数点，最终的结果只会是整数


**parseFloat()**

*   将内容转换成小数

*   从第一位开始检查，数字直接转换，可以认识一次小数点，直到第一个不是数字的内容就去掉

*   第一位就不是数字的，直接转换为 NaN

注意：parseInt和parseFloat解析会从第一字符进行解析，直到遇到不能被解析的字符为止，返回已经被解析的内容。

#### 转换为boolean

将得到的数据转换为number类型我们可以使用：

Boolean()

*   false、0、NaN、Undefined、null、空字符串 会被转换成false
*   其它的都会被转成true（任何非空字符串都会被转换为true）

注意：Boolean值在内存中true为1，false为0



### 自动类型转换---隐式转换

#### 转换为string

- `+` 号两边只要有一个是字符串，都会把另外一个转成字符串

#### 转换为number

对数字类型的自动转换我们可以使用：

*   直接在要转换的内容前加上”+”;

*   可以使用-、\*、/、%、>、<等将字符串转换成number

#### 转换为boolean

对于boolean类型的自动转换有很多操作可以实现，暂时我们学习过的有：逻辑运算符 ! 的操作。

```js
!12;// false 
!1;// false 
!'hello';// false 
!!'hello';// true 
!!123;// true
```

