# Option

`Option<T>`是一个特殊的枚举，用来表示一个值可能有值，也可能为**空**

在其他的语言中，往往都会有一个`null`关键字，用来表明当前变量的值为空，但在rust中需要使用`Option<T>`来表示空值

下面是`Option`在标准库中的定义

```rust
pub enum Option<T> {
    Some(T),
    None,
}
```

泛型参数：

- **T**：当值不为空时，被存储的值的类型，可以是任意类型

变体：

- **Some(T)**：当有值时，值被包含在这个Some里
- **None**：用来表示空值



`Option`有以下用途：

- 初始值
- 未在整个输入范围内定义的函数的返回值 (部分函数)
- 返回值，用于报告否则将报告简单错误的错误，其中错误返回 [`None`](https://www.rustwiki.org.cn/zh-CN/std/option/enum.Option.html#variant.None)
- 可选的结构体字段
- 可借用或 “taken” 的结构体字段
- 可选的函数参数
- 可空指针
- 从困难的情况中交换东西

:::tip

`Option<T>`在标准库的位置为` std::option::Option`

`Option<T>`在使用时不需要手动导入，`rust`已经自动导入了

:::



## 1.基本使用

`Option<T>` 枚举是如此有用以至于它被包含在了 [`prelude`](https://course.rs/appendix/prelude.html)（**prelude 属于 Rust 标准库，Rust 会将最常用的类型、函数等提前引入其中，省得我们再手动引入**）之中，你不需要将其显式引入作用域。

另外，它的成员 `Some` 和 `None` 也是如此，无需使用 `Option::` 前缀就可直接使用 `Some` 和 `None`。

比如下面一段代码

```rust
let maybe_number: Option<i32> = Option::Some(5);
let absent: Option<i32> = Option::None;
```

完全可以去掉`Option::`，然后使用下面的方式

```rust
let maybe_number: Option<i32> = Some(5);
let absent: Option<i32> = None;
```





:::warning 注意

1.当使用`Some(T)`时，因为`Some`肯定是有值的，所以即使不显示声明类型，rust也会自动推导`T`的类型

如果使用 `None` 而不是 `Some`，需要告诉 Rust `Option<T>` 是什么类型的，因为编译器只通过 `None` 值无法推断出 `Some` 成员保存的值的类型。

```rust
let some_number = Some(5);
let some_string = Some("a string");

let absent_number: Option<i32> = None;
```



2.`Some(T)`和`T`并不是一样的，两种类型不能混为一谈，比如下面这段代码

```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
```

由于类型不同，所以不能相加，从而会报错

:::



## 2.模式匹配

`Option<T>`既然是个枚举，那么就可以使用`match`进行模式匹配

```rust
let num = Some(66);
match num {
    Some(value) => println!("{}", value),
    None => (),
}
```

当匹配到`Some`时，被匹配的变量的值就会赋值给`Some()`的参数，在`Some`后的`{}`块中就可以使用这个变量的值



### 2.1 作为函数返回值

`Option<T>`通常作为函数的返回值

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

fn main() {
    let five = Some(5);
    let six: Option<i32> = plus_one(five);
    let none = plus_one(None);

    println!("{:?}", six);          // Some(6)
    println!("{:?}", none);         // None

}
```



### 2.2 给外面变量赋值

`Some(T)`毕竟不能跟别的类型一块运算，但是可以通过`match`修改外部变量的值，从而进一步运算

```rust
let age = Some(19);

let is_adult = match age {
    Some(value) => {
        if value>=18 {true} else{false}
    }
    None => false,
};

println!("{}", is_adult); // true
```

想取出`Some(T)`的值，也可以使用`Option<T>`的`unwrap()`方法，后面会有介绍



### 2.3 if let

`if let`是`match`的一个语法糖，常用于简化`Option`和`Result`的`match`语句先看如下代码

```rust
let num = Some(66);
match num {
    Some(value) => println!("{}", value),
    None => (),
}
```

在很多时候如上面这样，我们只会关心当Option为Some时的情况，而None则一笔带过

`if let`可以让我们直接处理Some的情况，而不管None的情况，语法如下

```rust
let num=Some(123);

if let Some(value) = num {
    println!("{}", value);		// 123
}
```

`Some(value) = num` 意思是判断变量`num`是否是一个`Some`，如果是`Some`，就把`num`的值赋值给`value`，可以在后面的语句块中访问这个value



### 2.4 ?运算符

?运算符是一个错误传播运算符，它用于简化错误处理。

当一个返回`Option`的函数（暂称`fn1`）中使用了另一个返回`Option`的函数（暂称`fn2`），使用`?`运算符可以减少`match`语句的使用

- 如果`fn2`返回的结果是Some，?会直接解包出内部的值，并继续执行
- 如果`fn2`返回的结果是None，?会直接将整个函数返回None

当表达式返回Some时

```rust
fn fn1() -> Option<bool> {
    return Some(true);
}

fn fn2() -> Option<bool> {
    let is_true = fn1()?;
    println!("{}",is_true);     // true

    if is_true { Some(true) } else { Some(false) }
}

fn main() {
    let res = fn2();
    println!("{:?}", res) // Some(true)
}
```

当表达式返回None时

```rust
fn fn1() -> Option<bool> {
    return None;
}

fn fn2() -> Option<bool> {
    let is_true = fn1()?;   // 直接返回None，后面代码不会执行
    println!("{}", is_true); 

    if is_true { Some(true) } else { Some(false) }
}

fn main() {
    let res = fn2();
    println!("{:?}", res) // Some(true)
}

```



除了`if let`，还有别的一些类似的语法糖，在模式匹配中有详细讲解

## 3.方法

以下是`Option<T>`中的方法

### impl\<T> Option\<T>

#### is_some

判断调用对象是否为`Some`，返回布尔值

```rust
pub const fn is_some(&self) -> bool
```

**返回值**：根据调用对象是否为`Some`，返回`bool`

```rust
let x: Option<u32> = Some(2);
println!("{}", x.is_some());		// true

let x: Option<u32> = None;
println!("{}", x.is_some());		// false
```

**源码**：

```rust
#[must_use = "if you intended to assert that this has a value, consider `.unwrap()` instead"]
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
#[rustc_const_stable(feature = "const_option_basics", since = "1.48.0")]
pub const fn is_some(&self) -> bool {
    matches!(*self, Some(_))
}
```



#### is_some_and

判断调用对象是否为`Some`

- 如果调用对象为`Some`，则把`Some`里的值赋值给闭包函数的参数，最后返回闭包函数的返回值
- 如果调用对象为`None`，闭包不会执行,则直接返回`false`

```rust
pub fn is_some_and(self, f: impl FnOnce(T) -> bool) -> bool
```

**参数**：

- f：闭包函数，当调用对象为`Some`时，会把`Some(T)`中`T`的值给`FnOnce(T)`的`T`

**返回值**：`bool`

- 若调用对象为`Some`，则返回闭包函数的返回值
- 若调用对象为`None`，则返回`false`

```rust
// 当self为Some
let s = Some(11);

let res = s.is_some_and(|x| x > 10);

println!("{}", res); // true

// 当self为None
let s: Option<i32> = None;

let res = s.is_some_and(|x| x > 10);

println!("{}", res); // false
```

**源码**：

```rust
#[must_use]
#[inline]
#[stable(feature = "is_some_and", since = "1.70.0")]
pub fn is_some_and(self, f: impl FnOnce(T) -> bool) -> bool {
    match self {
        None => false,
        Some(x) => f(x),
    }
}
```



#### is_none

判断调用对象是否为`None`

```rust
pub const fn is_none(&self) -> bool
```

**返回值**：根据调用对象是否为`None`，返回`bool`值

```rust
let x: Option<u32> = Some(2);
println!("{}", x.is_none());		// false

let x: Option<u32> = None;
println!("{}", x.is_none());		// true
```

**源码**：

```rust
#[must_use = "if you intended to assert that this doesn't have a value, consider \
    `.and_then(|_| panic!(\"`Option` had a value when expected `None`\"))` instead"]
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
#[rustc_const_stable(feature = "const_option_basics", since = "1.48.0")]
pub const fn is_none(&self) -> bool {
    !self.is_some()
}
```



#### as_ref

用于类型转换的方法，从 `&Option<T>` 转换为 `Option<&T>`。它的核心作用是在**不转移所有权**的前提下，将一个值转换为其引用形式。

```rust
pub const fn as_ref(&self) -> Option<&T>
```

**返回值**：返回一个不可变借用`Option<&T>`

```rust
let maybe_name: Option<String> = Some("Alice".to_string());

// 正确做法：使用 `as_ref` 先转换为引用
let length = maybe_name.as_ref().map(|s| s.len()); // `s` 是 `&String` 类型
println!("The length is: {:?}", length); // 输出：Some(5)
println!("Original option is still here: {:?}", maybe_name); // 输出：Some("Alice")
```

**源码**：

```rust
#[inline]
#[rustc_const_stable(feature = "const_option_basics", since = "1.48.0")]
#[stable(feature = "rust1", since = "1.0.0")]
pub const fn as_ref(&self) -> Option<&T> {
    match *self {
        Some(ref x) => Some(x),
        None => None,
    }
}
```





#### as_mut

从 `&mut Option<T>` 转换为 `Option<&mut T>`。

用于从 `Option<T>`创建一个对内部值的**可变引用** `Option<&mut T>`，允许你修改内部值而不获取其所有权。

```rust
pub fn as_mut(&mut self) -> Option<&mut T>
```

返回值：返回`Option`内部值的可变引用

```rust
let mut maybe_greeting = Some("Hello".to_string());

// 使用 as_mut 获取内部值的可变引用
if let Some(greeting) = maybe_greeting.as_mut() {
    greeting.push_str(", world!"); // 通过可变引用修改字符串
    // greeting 是 &mut String 类型
}

 println!("{:?}", maybe_greeting); //Some("Hello, world!")
```

源码：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
#[rustc_const_unstable(feature = "const_option", issue = "67441")]
pub const fn as_mut(&mut self) -> Option<&mut T> {
    match *self {
        Some(ref mut x) => Some(x),
        None => None,
    }
}
```



#### as_pin_ref

从 `Pin<&Option<T>>` 到 `Option<Pin<&T>>`。

Pin：确保某些特定类型的值在内存中不会被移动，从而保证内存安全

```rust
pub fn as_pin_ref(self: Pin<&Option<T>>) -> Option<Pin<&T>>
```

返回值：返回`Option`内部被`Pin`值的不可变借用

```rust
let some_string = Some("Hello".to_string());
// 通常通过 `Box::pin` 将值固定在堆上
let pinned_option: Pin<Box<Option<String>>> = Box::pin(some_string);

// 使用 as_pin_ref 来获取内部值的固定引用
if let Some(pinned_ref) = pinned_option.as_pin_ref() {
    // 现在我们可以安全地使用这个被固定的字符串引用
    let string_slice: &str = &*pinned_ref; // 通过 Deref 解引用 Pin<&String> 到 &String，然后解引用为 &str
    println!("{}", string_slice); // 输出：Hello
}
```

源码：

```rust
#[inline]
#[must_use]
#[stable(feature = "pin", since = "1.33.0")]
#[rustc_const_unstable(feature = "const_option_ext", issue = "91930")]
pub const fn as_pin_ref(self: Pin<&Self>) -> Option<Pin<&T>> {
    match Pin::get_ref(self).as_ref() {
        // SAFETY: `x` 被固定，因为它来自被固定的 `self`。
        //
        Some(x) => unsafe { Some(Pin::new_unchecked(x)) },
        None => None,
    }
}
```



#### as_pin_mut

转换自 `Pin<&mut Option<T>>` 到 `Option<Pin<&mut T>>`。

```rust
pub fn as_pin_mut(self: Pin<&mut Option<T>>) -> Option<Pin<&mut T>>
```

返回值：返回`Option`内部被`Pin`值的可变引用

源码：

```rust
#[inline]
#[must_use]
#[stable(feature = "pin", since = "1.33.0")]
#[rustc_const_unstable(feature = "const_option_ext", issue = "91930")]
pub const fn as_pin_mut(self: Pin<&mut Self>) -> Option<Pin<&mut T>> {
    // SAFETY: `get_unchecked_mut` 从未用于在 `self` 内部移动 `Option`。
    // `x` 被固定，因为它来自被固定的 `self`。
    unsafe {
        match Pin::get_unchecked_mut(self).as_mut() {
            Some(x) => Some(Pin::new_unchecked(x)),
            None => None,
        }
    }
}
```



#### as_slice

将Option内布置转化为切片引用，**不会消耗**原始 `Option<T>`的所有权。

```rust
pub fn as_slice(&self) -> &[T]
```

**返回值**：返回`Option`内部值的切片引用

```rust
let s: Option<i32> = Some(11);
let res = s.as_slice();

println!("{:?}", res); // [11]

let s: Option<i32> = None;
let res = s.as_slice();

println!("{:?}", res); // []
```

**源码**：

```rust
#[inline]
#[must_use]
#[unstable(feature = "option_as_slice", issue = "108545")]
pub fn as_slice(&self) -> &[T] {
    // SAFETY: 当 `Option` 为 `Some` 时，我们使用的是指向，载荷，的实际指针，长度为 1，因此这相当于 `slice::from_ref`，因此是安全的。
    // 当 `Option` 为 `None` 时，使用的长度为 0，安全起见只需要对齐即可，因为 `&self` 是对齐的，使用的 offset 是对齐的倍数。
    //
    //
    // 在新版本中，内部函数总是返回一个指向 `T` 的边界和正确对齐位置的指针 (即使在 `None` 的情况下它只是填充)。
    //
    //
    //
    //
    //
    unsafe {
        slice::from_raw_parts(
            crate::intrinsics::option_payload_ptr(crate::ptr::from_ref(self)),
            usize::from(self.is_some()),
        )
    }
}
```



#### as_mut_slice

将Option内布置转化为切片的可变借用，

```rust
pub fn as_mut_slice(&mut self) -> &mut [T]
```

**返回值**：返回`Option`内部值的切片的可变借用

```rust
let mut s: Option<i32> = Some(11);
let res = s.as_mut_slice();

println!("{:?}", res); // [11]
res[0] = 22;
println!("{:?}", res); // [22]
```

**源码**：

```rust
#[inline]
#[must_use]
#[unstable(feature = "option_as_slice", issue = "108545")]
pub fn as_mut_slice(&mut self) -> &mut [T] {
    // SAFETY: 当 `Option` 为 `Some` 时，我们使用的是指向，载荷，的实际指针，长度为 1，因此这相当于 `slice::from_mut`，因此是安全的。
    // 当 `Option` 为 `None` 时，使用的长度为 0，安全起见只需要对齐即可，因为 `&self` 是对齐的，使用的 offset 是对齐的倍数。
    //
    //
    // 在新版本中，内部函数从可变引用创建 `*const T`，因此可以安全地转换回可变指针。
    // 与 `as_slice` 一样，内部函数总是返回指向 `T` 的边界内和正确对齐位置的指针 (即使在 `None` 的情况下它只是填充)。
    //
    //
    //
    //
    //
    //
    unsafe {
        slice::from_raw_parts_mut(
            crate::intrinsics::option_payload_ptr(crate::ptr::from_mut(self).cast_const())
            .cast_mut(),
            usize::from(self.is_some()),
        )
    }
}
```



#### expect

取出`Some`中的值

当`Option`不为`Some`时，可以自行确定`panic` 的消息内容

```rust
pub fn expect(self, msg: &str) -> T
```

**参数**：

- **msg**：自定义`panic`的消息内容

**返回值**：

- 若`self`为`Some`，则返回`Some`包含的值
- 若`self`为`None`，则触发`panic`，`panic`消息内容为参数`msg`的值

```rust
let s = Some(666);
let res = s.expect("你代码写错了伙计");
println!("{}", res);  // 666


let s: Option<i32> = None;
let res = s.expect("晚上等着加班吧");
println!("{}", res);        // panic 晚上等着加班吧
```

**源码**：

```rust
#[inline]
#[track_caller]
#[stable(feature = "rust1", since = "1.0.0")]
#[rustc_const_unstable(feature = "const_option", issue = "67441")]
pub const fn expect(self, msg: &str) -> T {
    match self {
        Some(val) => val,
        None => expect_failed(msg),
    }
}
```



#### unwrap

从 `Some(value)`中提取出 `value`。如果遇到 `None`或 `Err(error)`，则触发 `panic!`导致程序终止。

```rust
pub fn unwrap(self) -> T
```

返回值：

- 若调用对象为 `Some(value)`，则返回 `value`
- 若调用对象为 `None`，则触发 `panic!`

```rust
let some_value: Option<i32> = Some(42);
let v = some_value.unwrap();
println!("{}", v); // 42

let none_value: Option<i32> = None;
let v = none_value.unwrap(); // 程序在此 panic！
```

:::tip

潜在的运行时恐慌（panic），导致程序意外终止，不适合在生产代码中随意使用。

:::

源码：

```rust
#[inline]
#[track_caller]
#[stable(feature = "rust1", since = "1.0.0")]
#[rustc_const_unstable(feature = "const_option", issue = "67441")]
pub const fn unwrap(self) -> T {
    match self {
        Some(val) => val,
        None => panic("called `Option::unwrap()` on a `None` value"),
    }
}
```



#### unwrap_or

安全地提取 `Some(T)`中的值；遇到 `None`或 `Err(E)`时，返回一个指定的默认值。

```rust
pub fn unwrap_or(self, default: T) -> T
```

参数：

- **default**：当`self`为`None`时，需要返回的默认值

返回值：

- 若`self`为`Some`，则取出`Some`中的值并返回
- 若`self`为`None`，则返回传入的默认值

注意默认值的类型要和`Option<T>`的类型一致

源码：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn unwrap_or(self, default: T) -> T {
    match self {
        Some(x) => x,
        None => default,
    }
}
```



#### unwrap_or_else

如果`self`是`Some`的话，则取出`Some`的值，否则返回回调的返回值

```rust
pub fn unwrap_or_else<F>(self, f: F) -> T
where
    F: FnOnce() -> T,
```

**参数**：

- f：闭包回调，当self为None时，才会调用此函数

**返回值**：

- 若`self`为`Some`，则取出`Some`中的值并返回
- 若`self`为`None`，则返回`f`的返回值

```rust
let some_value: Option<i32> = Some(42);
let res = some_value.unwrap_or_else(|| 666);
println!("{}", res);        // 42

let some_value: Option<i32> = None;
let res = some_value.unwrap_or_else(|| 666);
println!("{}", res);        // 666
```

**源码**：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn unwrap_or_else<F>(self, f: F) -> T
where
	F: FnOnce() -> T,
{
    match self {
        Some(x) => x,
        None => f(),
    }
}
```



#### unwrap_or_default

如果self为Some，则取出Some的值并返回，否则返回`Option<T>`中T类型的默认值

比如：整数类型的默认值都是0，布尔的默认值是false

```rust
pub fn unwrap_or_default(self) -> T
where
    T: Default,
```

**返回值**：

- `self`为`Some`时，返回`Some`包含的值
- `self`为`None`时，返回`Option<T>`中T**类型的默认值**

```rust
let some_value: Option<i32> = Some(42);
let res: i32 = some_value.unwrap_or_default();
println!("{}", res); // 42

let some_value: Option<bool> = None;
let res = some_value.unwrap_or_default();
println!("{}", res); // false
```

**源码**：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn unwrap_or_default(self) -> T
where
	T: Default,
{
    match self {
        Some(x) => x,
        None => T::default(),
    }
}
```



#### unwrap_unchecked

在不检查self是否为None的情况下，直接取出Some中的值，如果self为None，则会报错

使用`unwrap_unchecked`需要包含在`unsafe`块中

```rust
pub unsafe fn unwrap_unchecked(self) -> T
```

**返回值**：

- 如果self为Some，则取出Some的值
- 如果self为None，则会报错

```rust
let x = Some("hello");
let value = unsafe { x.unwrap_unchecked() };
println!("{}", value); // hello

let x: Option<&str> = None;
assert_eq!(unsafe { x.unwrap_unchecked() }, "air"); // 报错：未定义的行为！
```

**源码**：

```rust
#[inline]
#[track_caller]
#[stable(feature = "option_result_unwrap_unchecked", since = "1.58.0")]
#[rustc_const_unstable(feature = "const_option_ext", issue = "91930")]
pub const unsafe fn unwrap_unchecked(self) -> T {
    debug_assert!(self.is_some());
    match self {
        Some(val) => val,
        // SAFETY: 调用者必须坚持安全保证。
        None => unsafe { hint::unreachable_unchecked() },
    }
}
```



#### map

将`Some`中的值取出，可以对之进行操作，最后再包装为`Some`返回

```rust
pub fn map<U, F>(self, f: F) -> Option<U>
where
    F: FnOnce(T) -> U,
```

**参数**：

- **f**：闭包函数
  - 若`self`为`Some`，则把`Some`所包含的值赋值给`f`的参数，可以在闭包函数中对其值进行操作后再返回，最终的返回结果依然是一个`Some`
  - 若`self`为`None`，则`map`直接返回`None`，不会调用`f`函数

**返回值**：

- 若`self`为`Some`，则返回处理后的`Some`
- 若`self`为`None`，则返回`None`

```rust
let some_value = Some(100);

let res = some_value.map(|x| {
    println!("{}", x);		// 100
    x * 2
});
println!("{:?}", res)		// Some(200)
```

**源码**：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn map<U, F>(self, f: F) -> Option<U>
where
	F: FnOnce(T) -> U,
{
    match self {
        Some(x) => Some(f(x)),
        None => None,
    }
}
```



#### map_or

当`self`为`None`时直接返回默认值，否则可在闭包函数f中将`Some`中的值处理并返回

```rust
pub fn map_or<U, F>(self, default: U, f: F) -> U
where
    F: FnOnce(T) -> U,
```

**参数**：

- **default**：当`self`为`None`时，`map_or`函数返回的默认值
- **f**：当`self`为`Some`时，`Some`中包含的值会被赋值给f的参数，最后`map_or`函数将会返回`f`的返回值

**返回值**：

- 若`self`为`None`，返回参数`default`的值
- 若`self`为`Some`时，返回参数`f`的返回值

```rust
// 当self为Some时
let some_value: Option<i32> = Some(100);
let res = some_value.map_or(160, |x| {
    println!("{}", x);			// 100
    x * 2
});
println!("{:?}", res)			// 200


// 当self为None时
let some_value: Option<i32> = None;
let res = some_value.map_or(160, |x| {
    println!("{}", x);	
    x * 2
});
println!("{:?}", res)		// 160
```

**源码**：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn map_or<U, F>(self, default: U, f: F) -> U
where
	F: FnOnce(T) -> U,
{
    match self {
        Some(t) => f(t),
        None => default,
    }
}
```



#### map_or_else

当`self`为`None`时返回`default`函数的返回值，否则可在闭包函数`f`中将`Some`中的值处理并返回

```rust
pub fn map_or_else<U, D, F>(self, default: D, f: F) -> U
where
    D: FnOnce() -> U,
    F: FnOnce(T) -> U,
```

参数：

- **default**：当self为None时，map_or会返回default函数的返回值
- **f**：当`self`为`Some`时，`Some`中包含的值会被赋值给f的参数，最后`map_or`函数将会返回`f`的返回值

返回值：

```rust
// 当self为Some时
let some_value: Option<i32> = Some(100);
let res = some_value.map_or_else(
    || 300,
    |x| {
        println!("{}", x);      // 100
        x * 2
    },
);
println!("{:?}", res)           // 200


// 当self为None时
let some_value: Option<i32> = None;
let res = some_value.map_or_else(
    || 300,
    |x| {
        println!("{}", x);      // 100
        x * 2
    },
);
println!("{:?}", res)           // 300
```

源码：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn map_or_else<U, D, F>(self, default: D, f: F) -> U
where
	D: FnOnce() -> U,
	F: FnOnce(T) -> U,
{
    match self {
        Some(t) => f(t),
        None => default(),
    }
}
```



#### ok_or

把`Option`转化为`Result`返回

```rust
pub fn ok_or<E>(self, err: E) -> Result<T, E>
```

参数：

- **err**：被转化为`Result`后，若`Result`返回为`Err`，给`Err`的参数

返回值：

- 若`self`为`None`，则返回`Result`的`Err`变体，并把**参数`err`**传递给`Result`的`Err()`变体
- 若`self`为`Some`，则返回`Result`的`Ok`变体，并把`Some`包含的值传递给`Result`的`Ok()`变体

```rust
// 当self为Some时
let some_value: Option<String> = Some("这是成功的结果".to_string());
let res = some_value.ok_or("失败了");
println!("{:?}", res) // Ok("这是成功的结果")


// 当self为None时
let some_value: Option<String> = None;
let res = some_value.ok_or("失败了");
println!("{:?}", res) // Err("失败了")
```

源码：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn ok_or<E>(self, err: E) -> Result<T, E> {
    match self {
        Some(v) => Ok(v),
        None => Err(err),
    }
}
```



#### ok_or_else

把`Option`转化为`Result`返回

```rust
pub fn ok_or_else<E, F>(self, err: F) -> Result<T, E>
where
    F: FnOnce() -> E,
```

参数：

- **err**：一个闭包函数，当`self`为`None`时，`ok_or_else`函数会把`err`函数的返回值传递给`Result`的`Err`变体

返回值：

- 若`self`为`None`，则返回`Result`的`Err`变体，并把**`err`函数的返回值**传递给`Result`的`Err()`变体
- 若`self`为`Some`，则返回`Result`的`Ok`变体，并把`Some`包含的值传递给`Result`的`Ok()`变体

```rust
// 当self为Some时
let some_value: Option<String> = Some("成功啦".to_string());
let res = some_value.ok_or_else(||"失败了");
println!("{:?}", res) // Ok("成功啦")

// 当self为None时
let some_value: Option<String> = None;
let res = some_value.ok_or_else(||"失败了");
println!("{:?}", res) // Err("失败了")
```

源码：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn ok_or_else<E, F>(self, err: F) -> Result<T, E>
where
	F: FnOnce() -> E,
{
    match self {
        Some(v) => Ok(v),
        None => Err(err()),
    }
}
```



#### inspect

nspect方法接受一个闭包作为参数。

- 当 `Option`是 `Some(value)`时，这个闭包会以不可变引用（&T）的方式接收到内部值 value，你可以查看或打印它，但**无法修改**。之后，inspect会原封不动地将原始的 `Option<T>`传递给链中的下一个操作。
- 如果 Option是 None，则闭包不会执行，None会直接继续传递。

```rust
pub fn inspect<F>(self, f: F) -> Option<T>
where
	F: FnOnce(&T),
```

参数：

- **f**：一个闭包函数，返回`Some(T)`中`T`的借用

返回值：

- 当`self`为`None`时，则返回`None`
- 当`self`为`Some`时，返回`Some(T)`中`T`的借用

```rust
let number = Some(5);

let final_result = number
.inspect(|x| println!("初始值: {}", x)) // 查看初始值
.map(|x| x * 3)                         // 将值乘以3
.inspect(|x| println!("乘以3后: {}", x)) // 查看map之后的值
.filter(|x| x > &10)                   // 过滤，只保留大于10的值
.inspect(|x| println!("过滤后保留的值: {}", x)); // 查看过滤后的结果

println!("最终结果: {:?}", final_result); // 输出: Some(15)
```

源码：

```rust
#[inline]
#[unstable(feature = "result_option_inspect", issue = "91345")]
pub fn inspect<F>(self, f: F) -> Self
where
	F: FnOnce(&T),
{
    if let Some(ref x) = self {
        f(x);
    }

    self
}
```



#### as_deref

可以看作为`as_ref().map(|s| s.deref())`的简写形式

从 `Option<T>` (或 `&Option<T>`) 转换为 `Option<&T::Target>`。

将原始 `Option` 保留在原位，创建一个带有对原始 `Option` 的引用的新 `Option`，并通过`Deref` 强制执行其内容。

```rust
pub fn as_deref(&self) -> Option<&<T as Deref>::Target>
where
    T: Deref,
```

**返回值**：返回内部值解引用后的不可变引用。T必须实现 Dereftrait。

假设你有一个 `Option<String>`，但你调用的函数期望一个 `Option<&str>`。

```rust
fn print_message(msg: Option<&str>) {
    if let Some(m) = msg {
        println!("Message: {}", m);
    } else {
        println!("No message");
    }
}

fn main() {
    let maybe_string: Option<String> = Some("Hello, Rust!".to_string());

    // 使用 as_deref 轻松完成转换
    print_message(maybe_string.as_deref()); // 输出: Message: Hello, Rust!

    // 对比：如果只用 as_ref，得到的是 Option<&String>，与函数签名不匹配
    // print_message(maybe_string.as_ref()); // 这行会编译错误

    // 对比：手动实现类似 as_deref 的效果，但更为繁琐
    // print_message(maybe_string.as_ref().map(|s| s.as_str()));
}
```

**源码**：

```rust
#[inline]
#[stable(feature = "option_deref", since = "1.40.0")]
pub fn as_deref(&self) -> Option<&T::Target>
where
	T: Deref,
{
    match self.as_ref() {
        Some(t) => Some(t.deref()),
        None => None,
    }
}
```



#### as_deraf_mut

可以看作为`as_ref().map(|s| s.deref_mut())`的简写形式

- 首先通过 `as_mut()`将 `&mut Option<T>`转换为 `Option<&mut T>`，避免所有权的转移。
- 然后对 `&mut T`调用 `deref_mut`方法（这通常由 Rust 的 **Deref 强制转换** 机制自动完成），最终得到指向内部数据（`U`）的可变引用 `&mut U`。

```rust
pub fn as_deref_mut(&mut self) -> Option<&mut <T as Deref>::Target>
where
    T: DerefMut,
```

返回值：返回内部值解引用后的**可变引用**。`T`必须实现 `DerefMut`trait。

```rust
fn make_ascii_lowercase(s: Option<&mut str>) {
    if let Some(s_ref) = s {
        s_ref.make_ascii_lowercase();
    }
}

fn main() {
    let mut maybe_name = Some("Alice".to_string()); // Option<String>
    
    // 使用 as_deref_mut 转换为 Option<&mut str> 后传入函数
    make_ascii_lowercase(maybe_name.as_deref_mut());
    
    println!("{:?}", maybe_name); // 输出: Some("alice")
}
```

源码：

```rust
#[inline]
#[stable(feature = "option_deref", since = "1.40.0")]
pub fn as_deref_mut(&mut self) -> Option<&mut T::Target>
where
	T: DerefMut,
{
    match self.as_mut() {
        Some(t) => Some(t.deref_mut()),
        None => None,
    }
}
```



#### iter

将 `Option<T>`转换成一个**生成单个元素的迭代器**（如果值是 `Some(T)`），或者一个**空迭代器**（如果值是 `None`）

```rust
pub fn iter(&self) -> Iter<'_, T>
```

返回值：返回一个包含`Option`内变体的迭代器，通过`next`方法可以获取其值

```rust
// 当self为Some
let x: Option<i32> = Some(4);
let mut res = x.iter();
println!("{:?}", res); // Iter { inner: Item { opt: Some(4) } }
println!("{:?}", res.next()); // Some(4) 

// 当self为None
let x: Option<i32> = None;
let mut res = x.iter();
println!("{:?}", res); // Iter { inner: Item { opt: None } }
println!("{:?}", res.next()); // None
```

源码：

```rust
#[inline]
#[rustc_const_unstable(feature = "const_option", issue = "67441")]
#[stable(feature = "rust1", since = "1.0.0")]
pub const fn iter(&self) -> Iter<'_, T> {
    Iter { inner: Item { opt: self.as_ref() } }
}
```



#### iter_mut

将 `Option<T>`转换成一个**生成单个元素的可变迭代器**（如果值是 `Some(T)`），或者一个**空迭代器**（如果值是 `None`）

```rust
pub fn iter_mut(&mut self) -> IterMut<'_, T>
```

参数：

返回值：返回一个包含`Option`内变体的**可变迭代器**，通过`next`方法可以获取其值

```rust
// 当self为Some
let mut x: Option<i32> = Some(4);
let mut res = x.iter_mut();

if let Some(value) = res.next() {
    *value += 10;
}
println!("{:?}", x); // Some(14) 

// 当self为None
let mut x: Option<i32> = None;
let mut res = x.iter_mut();
if let Some(value) = res.next() {
    *value += 10;
}
println!("{:?}", x); // None
```

源码：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn iter_mut(&mut self) -> IterMut<'_, T> {
    IterMut { inner: Item { opt: self.as_mut() } }
}
```



#### and

接收一个`Option`参数，把自身和参数进行**逻辑与**，也就是`&&`

- 如果自身为`None`，则返回`None`，不会进行后面的判断
- 如果自身不为`None`，则返回参数的值

```rust
pub fn and<U>(self, optb: Option<U>) -> Option<U>
```

参数：

- optb：需要进行逻辑与运算的`Option`

返回值：如果`self`为 `None`，则返回`None`; 否则，返回 参数`optb`。

```rust
// 自身不为None，参数为None
let x = Some(2);
let y: Option<&str> = None;
println!("{:?}", x.and(y));         // None

// 自身不为None，参数不为None
let x: Option<u32> = Some(2);
let y = Some("foo");
println!("{:?}", x.and(y));         // Some("foo")

// 自身为None，参数不为None
let x: Option<u32> = None;
let y = Some("foo");
println!("{:?}", x.and(y));         // None

// 自身为None，参数为None
let x: Option<u32> = None;
let y: Option<&str> = None;
println!("{:?}", x.and(y));         // None
```

源码：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn and<U>(self, optb: Option<U>) -> Option<U> {
    match self {
        Some(_) => optb,
        None => None,
    }
}
```



#### and_then

接受一个返回`Option`类型的闭包（函数）

- 如果自身为`None`，则返回`None`，不会进行后面的判断
- 如果自身不为`None`，则把自身`Some(T)`中`T`的值作为`f`的参数，最后返回`f`的返回值

```rust
pub fn and_then<U, F>(self, f: F) -> Option<U>
where
    F: FnOnce(T) -> Option<U>,
```

参数：

- f：一个返回`Option`的闭包函数

返回值：

- 如果自身为`None`，则返回`None`
- 如果自身不为`None`，则返回`f`的返回值

```rust
let num: Option<i32>=Some(3);

let result = num.and_then(|x| {
    println!("x的值为：{:?}", x);   // x的值为：3
    Some(x * 2)
});

println!("{:?}", result) // Some(6)
```

源码：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn and_then<U, F>(self, f: F) -> Option<U>
where
F: FnOnce(T) -> Option<U>,
{
    match self {
        Some(x) => f(x),
        None => None,
    }
}
```



#### filter

根据传入的谓词判断，返回自身或None

```rust
pub fn filter<P>(self, predicate: P) -> Option<T>
where
    P: FnOnce(&T) -> bool,
```

**参数**：

- **predicate**：一个闭包函数作为谓词，返回一个`bool`值
  - 注意`predicate`函数中，`Some`包含的数被**借用**到`predicate`的参数中，在`predicate`函数中使用该参数需要使用解引用符号`*`

**返回值**：

- 如果`predicate`返回`true`，则返回`self`本身的值
- 如果`predicate`返回`false`，则返回`None`

```rust
// 当谓词为真
let some_value: Option<u8> = Some(5);
let res = some_value.filter(|x| if *x < 10 { true } else { false });

println!("{:?}", res)           // Some(5)


// 当谓词为假
let some_value: Option<u8> = Some(5);
let res = some_value.filter(|x| if *x > 10 { true } else { false });

println!("{:?}", res)           // None
```

**源码**：

```rust
#[inline]
#[stable(feature = "option_filter", since = "1.27.0")]
pub fn filter<P>(self, predicate: P) -> Self
where
	P: FnOnce(&T) -> bool,
{
    if let Some(x) = self {
        if predicate(&x) {
            return Some(x);
        }
    }
    None
}
```



#### or

判断`self`是否为`Some`，返回`Some`本身或者传入参数的值

```rust
pub fn or(self, optb: Option<T>) -> Option<T>
```

**参数**：

- **optb**：当`self`为None时，`or`函数把`optb`作为返回值

**返回值**：

- 当`self`为`Some`时，返回`Some`本身
- 当`self`为`None`时，返回传入的`optb`的值

```rust
// 当self为Some时
let some_value: Option<u8> = Some(5);
let res = some_value.or(Some(6));
println!("{:?}", res)           // Some(5)

// 当self为None时
let some_value: Option<u8> = None;
let res = some_value.or(Some(6));
println!("{:?}", res) 			// Some(6)
```

**源码**：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn or(self, optb: Option<T>) -> Option<T> {
    match self {
        Some(x) => Some(x),
        None => optb,
    }
}
```



#### or_else

判断`self`是否为`Some`，返回`Some`本身或者传入函数的返回值

```rust
pub fn or_else<F>(self, f: F) -> Option<T>
where
    F: FnOnce() -> Option<T>,
```

参数：

- **f**：当`self`为None时，`or_else`函数返回`f`函数的返回值

返回值：

- 当`self`为`Some`时，返回`Some`本身
- 当`self`为`None`时，返回传入的`f`函数的返回值

```rust
// 当self为Some时
let some_value: Option<u8> = Some(5);
let res = some_value.or_else(|| Some(6));
println!("{:?}", res)           // Some(5)

// 当self为None时
let some_value: Option<u8> = None;
let res = some_value.or_else(|| Some(6));
println!("{:?}", res) 			// Some(6)
```

**源码**：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn or_else<F>(self, f: F) -> Option<T>
where
	F: FnOnce() -> Option<T>,
{
    match self {
        Some(x) => Some(x),
        None => f(),
    }
}
```



#### xor

把`self`和`optb`做异或判断，如果 `self`，`optb` 之一恰好是 `Some`，则返回 `Some`，否则返回 `None`。

```rust
pub fn xor(self, optb: Option<T>) -> Option<T>
```

**参数**：

- **optb**：需要做异或的参数

**返回值**：

- 如果 `self`，`optb`只要有一个是`Some`，则哪个是`Some`就返回哪个`Some`
- 如果 `self`，`optb`两个都是`None`，则返回`None`

**源码**：

```rust
#[inline]
#[stable(feature = "option_xor", since = "1.37.0")]
pub fn xor(self, optb: Option<T>) -> Option<T> {
    match (self, optb) {
        (Some(a), None) => Some(a),
        (None, Some(b)) => Some(b),
        _ => None,
    }
}
```



#### insert

用于把`Option`容器中的值**替换成一个新值**，并**返回这个值的可变引用**。

**无论 `Option`原来的状态是什么，调用后它都会变成 `Some`**，并且如果原来有值，那个旧值会被替换掉。

```rust
pub fn insert(&mut self, value: T) -> &mut T
```

**参数**：

- **value**：需要被插入的值

**返回值**：

- 返回替换后的值的可变引用

```rust
// 向 None 中插入值
let mut maybe_name: Option<String> = None;
let name_ref = maybe_name.insert("Alice".to_string());

// 由于返回的是可变引用，我们可以直接修改它
name_ref.push_str(" Smith");
println!("修改后: {:?}", maybe_name); // 输出: Some("Alice Smith")



// 替换 Some 中的旧值
let mut number = Some(10);
// 替换旧值 10，返回新值 42 的可变引用
let new_num_ref = number.insert(42);
println!("替换后: {:?}", number); // 输出: Some(42)

// 同样可以直接修改
*new_num_ref += 1;
println!("再次修改后: {:?}", number); // 输出: Some(43)
```

源码：

```rust
#[must_use = "if you intended to set a value, consider assignment instead"]
#[inline]
#[stable(feature = "option_insert", since = "1.53.0")]
pub fn insert(&mut self, value: T) -> &mut T {
    *self = Some(value);

    // SAFETY: 上面的代码刚刚填满了该选项
    unsafe { self.as_mut().unwrap_unchecked() }
}
```



#### get_or_insert

如果self为None，则将`None`**替换成一个新值**，并**返回这个值的可变引用**。新值改变，旧值也会改变

否则返回Some包含的值的可变引用

```rust
pub fn get_or_insert(&mut self, value: T) -> &mut T
```

参数：

- **value**：需要被插入的值

**返回值**：

- 返回替换后的值的可变引用

```rust
// 当self为Some时
let mut some_value = Some(66);
let res = some_value.get_or_insert(77);
println!("{}", res); // 66
*res += 10; // 可以改变
println!("{}", res); // 76


// 当self为None时
let mut some_value: Option<i32> = None;
let res = some_value.get_or_insert(77);
println!("{}", res); // 77
*res += 10; // 可以改变
println!("{}", res); // 87
```

源码：

```rust
#[inline]
#[stable(feature = "option_entry", since = "1.20.0")]
pub fn get_or_insert(&mut self, value: T) -> &mut T {
    if let None = *self {
        *self = Some(value);
    }

    // SAFETY: 在上面的代码中，用于 `self` 的 `None` 变体将被替换为 `Some` 变体。
    //
    unsafe { self.as_mut().unwrap_unchecked() }
}
```





#### get_or_insert_with

如果`self`为`None`，则把`f`的返回值放入`Some`中，并返回该值的可变引用。新值改变，旧值也会改变

如果`self`为`Some(T)`，则返回`T`的可变引用

```rust
pub fn get_or_insert_with<F>(&mut self, f: F) -> &mut T
where
    F: FnOnce() -> T,
```

参数：

- **f**：当`self`为`None`时，触发`f`函数，并将f函数的返回值返回出去

返回值：

- 若`self`为`None`，则返回`fn()`返回值的可变引用 
- 若`self`为`Some(T)`，则返回`T`的可变引用

```rust
// 当self为Some时
let mut some_value = Some(66);
let res = some_value.get_or_insert_with(|| 111);
println!("{}", res); // 66
*res += 10; // 可以改变
println!("{}", res); // 76

println!("{:?}", some_value); // 76， 原来的值也被改变

// 当self为None时
let mut some_value: Option<i32> = None;
let res = some_value.get_or_insert_with(|| 222);
println!("{}", res); // 222
*res += 10; // 可以改变
println!("{}", res); // 232
```

源码：

```rust
#[inline]
#[stable(feature = "option_entry", since = "1.20.0")]
pub fn get_or_insert_with<F>(&mut self, f: F) -> &mut T
where
	F: FnOnce() -> T,
{
    if let None = self {
        *self = Some(f());
    }

    // SAFETY: 在上面的代码中，用于 `self` 的 `None` 变体将被替换为 `Some` 变体。
    //
    unsafe { self.as_mut().unwrap_unchecked() }
}
```



#### get_or_insert_default

`Option`为 `None`时，会使用`T`**类型的默认值**（如：i32的默认值是0）进行插入，并返回一个指向内部值的可变引用

```rust
pub fn get_or_insert_default(&mut self) -> &mut T
where
    T: Default,
```

**返回值**：

- 若`self`为`None`，则返回`Option<T>`中**T类型的默认值**的可变引用
- 若`self`为`Some`，则返回`Some`包含的值的可变引用

```rust
// 当self为Some时
let mut some_value = Some(66);
let res = some_value.get_or_insert_default();
println!("{}", res); // 66
*res += 10; // 可以改变
println!("{}", res); // 76

// 当self为None时
let mut some_value: Option<i32> = None;
let res = some_value.get_or_insert_default();
println!("{}", res); // 0    i32类型的默认值
*res += 10; // 可以改变
println!("{}", res); // 10
```

**源码**：

```rust
#[inline]
#[unstable(feature = "option_get_or_insert_default", issue = "82901")]
pub fn get_or_insert_default(&mut self) -> &mut T
where
	T: Default,
{
    self.get_or_insert_with(T::default)
}
```



#### replace

用于**替换 `Option`内部的值，并返回被替换的旧值**。这是一个会修改原 `Option`的操作。

```rust
pub fn replace(&mut self, value: T) -> Option<T>
```

**参数**：

- **value**：需要被替换的新值

**返回值**：返回被替换的旧值

```rust
// 当self为Some时
let mut x = Some(2);
let old = x.replace(5); // 用 5 替换原来的 2

println!("{:?}", old); // Some(2)
println!("{:?}", x); // Some(5)


// 当self为None时
let mut x: Option<i32> = None;
let old = x.replace(5); // 用 5 替换原来的 None

println!("{:?}", old); // None
println!("{:?}", x); // Some(5)
```

**源码**：

```rust
#[inline]
#[rustc_const_unstable(feature = "const_option", issue = "67441")]
#[stable(feature = "option_replace", since = "1.31.0")]
pub const fn replace(&mut self, value: T) -> Option<T> {
    mem::replace(self, Some(value))
}
```



#### take

**安全地将 `Option<T>`实例中的值移出，并同时将原 `Option`设置为 `None`**。这个方法允许你在不破坏所有权规则的前提下，转移 `Option`内部值的所有权。

```rust
pub fn take(&mut self) -> Option<T>
```

返回值：

- 返回`self`的值

```rust
// 当self为Some时   
let mut x = Some(2);
let res: Option<i32> = x.take(); // 用 5 替换原来的 2

println!("{:?}", res); // Some(2)
println!("{:?}", x); // None


// 当self为None时
let mut x: Option<i32> = None;
let res = x.take(); // 用 5 替换原来的 2

println!("{:?}", res); // None
println!("{:?}", x); // None
```

源码：

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
#[rustc_const_unstable(feature = "const_option", issue = "67441")]
pub const fn take(&mut self) -> Option<T> {
    // FIXME 当后者准备好时，用 `mem::take` 替换 `mem::replace`
    mem::replace(self, None)
}
```



#### zip

把`self`和另一个`Some`，合并成一个`Some`元组

```rust
pub fn zip<U>(self, other: Option<U>) -> Option<(T, U)>
```

参数：

- **other**：需要合并的另一个`Option`

返回值：返回被合并的Some元组

- 如果`self`和`other`都为`Some`，则返回一个`Some`元组。如果`self`为`Some(a)`，`other`为`Some(b)`，那么返回`Some((a, b))`
  - 元组第一个值为`self`中`Some`包含的值
  - 元组第二个值为`other`中`Some`包含的值
- `self`和`other`只要有一个为`None`，则zip就返回`None`

```rust
// 当self和other都是Option
let num1: Option<i32> = Some(11);
let res = num1.zip(Some(22));

println!("{:?}", res); // Some((11, 22))

// 当self是None
let num1: Option<i32> = None;
let res = num1.zip(Some(22));

println!("{:?}", res); // None

// 当other为None
let num1: Option<i32> = Some(11);
let res: Option<(i32, i32)> = num1.zip(None);

println!("{:?}", res); // None
```

源码：

```rust
#[stable(feature = "option_zip_option", since = "1.46.0")]
pub fn zip<U>(self, other: Option<U>) -> Option<(T, U)> {
    match (self, other) {
        (Some(a), Some(b)) => Some((a, b)),
        _ => None,
    }
}
```



#### zip_with

`self`和`other`都为`Some`的情况下，把`self`和`other`的`Some`包含的值分别赋值给`f`的两个参数，最后返回`f`函数的返回值

```rust
pub fn zip_with<U, F, R>(self, other: Option<U>, f: F) -> Option<R>
where
    F: FnOnce(T, U) -> R,
```

**参数**：

- **other**：需要合并的另一个`Option`
- **f**：用来处理`self`和`other`的`Some`包含的值的闭包函数

返回值：

- 如果`self`和`other`都为`Some`，则把`self`和`other`中`Some`包含的值分别赋值给f函数的两个参数，最后返回`f`函数的返回值
- `self`和`other`只要有一个为`None`，则zip就返回`None`

```rust
let num1: Option<i32> = Some(11);
let res = num1.zip_with(Some(22), |x, y| {
    println!("x:{},y:{}", x, y);
    x + y
});

println!("{:?}", res); // Some((11, 22))

// 使用这个方法会报错use of unstable library feature `option_zip`，不知道为啥，后面学了再回来看
```

源码：

```rust
#[unstable(feature = "option_zip", issue = "70086")]
pub fn zip_with<U, F, R>(self, other: Option<U>, f: F) -> Option<R>
where
	F: FnOnce(T, U) -> R,
{
    match (self, other) {
        (Some(a), Some(b)) => Some(f(a, b)),
        _ => None,
    }
}
```



### impl<T, U> Option<(T, U)>

以下是接受一个两值元组的`Option`方法

#### unzip

解压缩包含两个选项的元组的选项。

如果 `self` 是 `Some((a, b))`，则此方法返回 `(Some(a), Some(b))`。 否则，返回 `(None, None)`。

```rust
pub fn unzip(self) -> (Option<T>, Option<U>)
```

返回值：

- 如果 `self` 是 `Some((a, b))`，则此方法返回 `(Some(a), Some(b))`。
- 否则，返回 `(None, None)`。
  - **注意**，如果`self`为`None`，需要给给`None`显示传入泛型参数

```rust
let x = Some((1, "hi"));
let y = None::<(u8, u32)>;

println!("{:?}",x.unzip());     // (Some(1), Some("hi"))
println!("{:?}",y.unzip());     // (None, None)
```



源码：

```rust
#[inline]
#[stable(feature = "unzip_option", since = "1.66.0")]
pub fn unzip(self) -> (Option<T>, Option<U>) {
    match self {
        Some((a, b)) => (Some(a), Some(b)),
        None => (None, None),
    }
}
```



### impl\<T> Option<&T>

#### copied

返回整数、浮点数、布尔值等基本类型`Option`的**浅拷贝的不可变借用**

```rust
pub fn copied(self) -> Option<T>
where
    T: Copy,
```

**返回值**：返回`self`的浅拷贝不可变借用

```rust
let num = 123;
let s = Some(&num);
let s_copy = s.copied();

println!("{:?}", s_copy);       // Some(123)
```

**源码**：

```rust
#[must_use = "`self` will be dropped if the result is not used"]
#[stable(feature = "copied", since = "1.35.0")]
#[rustc_const_unstable(feature = "const_option", issue = "67441")]
pub const fn copied(self) -> Option<T>
where
	T: Copy,
{
    // FIXME: 此实现避开使用 `Option::map`，因为它尚未准备好常量，应尽可能还原以避免代码重复
    //
    match self {
        Some(&v) => Some(v),
        None => None,
    }
}
```



#### cloned

返回字符串、集合等复杂类型`Option`的**深拷贝的不可变借用**

```rust
pub fn cloned(self) -> Option<T>
where
    T: Clone,
```

**返回值**：返回`self`的深拷贝的不可变借用

```rust
let str = String::from("ikun");
let s = Some(&str);
let s_copy = s.cloned();

println!("{:?}", s_copy); // Some("ikun")
```

**源码**：

```rust
#[must_use = "`self` will be dropped if the result is not used"]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn cloned(self) -> Option<T>
where
	T: Clone,
{
    match self {
        Some(t) => Some(t.clone()),
        None => None,
    }
}
```



### impl\<T> Option<&mut T>

#### copied

返回整数、浮点数、布尔值等基本类型`Option`的**浅拷贝的可变借用**

```rust
pub fn copied(self) -> Option<T>
where
    T: Copy,
```

**返回值**：返回`self`的浅拷贝可变借用

```rust
let mut num = 123;
let s = Some(&mut num);
let s_copy = s.cloned();

if let Some(mut value) = s_copy {
    value += 10;
    println!("{:?}", value); // 133
}
```

源码：

```rust
#[must_use = "`self` will be dropped if the result is not used"]
#[stable(feature = "copied", since = "1.35.0")]
#[rustc_const_unstable(feature = "const_option_ext", issue = "91930")]
pub const fn copied(self) -> Option<T>
where
	T: Copy,
{
    match self {
        Some(&mut t) => Some(t),
        None => None,
    }
}
```



#### cloned

返回字符串、集合等复杂类型`Option`的**深拷贝的可变借用**

```rust
pub fn cloned(self) -> Option<T>
where
    T: Clone,
```

**返回值**：返回`self`的深拷贝的可变借用

```rust
let mut str = String::from("ikun");
let s = Some(&mut str);
let s_copy = s.cloned();

if let Some(mut value) = s_copy {
    value.push_str("小黑子");
    println!("{:?}", value); // "ikun小黑子"
}
```

源码：

```rust
#[must_use = "`self` will be dropped if the result is not used"]
#[stable(since = "1.26.0", feature = "option_ref_mut_cloned")]
pub fn cloned(self) -> Option<T>
where
	T: Clone,
{
    match self {
        Some(t) => Some(t.clone()),
        None => None,
    }
}
```



### impl<T, E> Option<Result<T, E>>

#### transpose

将 `Result` 的 `Option` 转换为 `Option` 的 `Result`。

`None` 将映射到 `Ok(None)`。 `Some(Ok(_))` 和 `Some(Err(_))` 将映射到 `Ok(Some(_))` 和 `Err(_)`

```rust
pub fn transpose(self) -> Result<Option<T>, E>
```

**返回值**：

- 当`self`为`Some`时
  - 若`Some`包含`Ok(x)`，则返回`Ok(Some())`
  - 若`Some`包含`Err(e)`，则返回`Err(e)`
- 当`self`为`None`时：返回`Ok(None)`

```rust
fn result(num: u8) -> Result<bool, String> {
    if num > 10 {
        Ok(true)
    } else {
        Err("error".to_string())
    }
}

fn main() {
    let s: Option<Result<bool, String>> = Some(result(5));
    let res: Result<Option<bool>, String> = s.transpose();

    println!("{:?}", res); // Err("error")


    let s: Option<Result<bool, String>>  = Some(result(20));
    let res: Result<Option<bool>, String> = s.transpose();

    println!("{:?}", res); // Ok(Some(true))
}

```

**源码**：

```rust
#[inline]
#[stable(feature = "transpose_result", since = "1.33.0")]
#[rustc_const_unstable(feature = "const_option", issue = "67441")]
pub const fn transpose(self) -> Result<Option<T>, E> {
    match self {
        Some(Ok(x)) => Ok(Some(x)),
        Some(Err(e)) => Err(e),
        None => Ok(None),
    }
}
```



### impl\<T> Option<Option\<T>>

#### flatten

从 `Option<Option<T>>` 转换为 `Option<T>`。

```rust
pub fn flatten(self) -> Option<T>
```

返回值：

- 若self为Some，则返回解包后的Some
- 若self为None，返回None

```rust
let s = Some(Some(666));

let res = s.flatten();

println!("{:?}", res) // Some(666)
```

源码：

```rust
#[inline]
#[stable(feature = "option_flattening", since = "1.40.0")]
#[rustc_const_unstable(feature = "const_option", issue = "67441")]
pub const fn flatten(self) -> Option<T> {
    match self {
        Some(inner) => inner,
        None => None,
    }
}
```











## 4.特征Trait实现

### Clone

### Debug

### Default

### From

Option一共实现了三种From的trait：

#### From\<T>

```rust
#[stable(since = "1.12.0", feature = "option_from")]
impl<T> From<T> for Option<T> {
    fn from(val: T) -> Option<T> {
        Some(val)
    }
}
```

根据from的参数创建一个Some

```rust
let o: Option<u8> = Option::from(67);

println!("{:?}", o) // Some(67)
```



#### From<&'a Option\<T>>

```rust
#[stable(feature = "option_ref_from_ref_option", since = "1.30.0")]
impl<'a, T> From<&'a Option<T>> for Option<&'a T> {
    fn from(o: &'a Option<T>) -> Option<&'a T> {
        o.as_ref()
    }
}
```

从 `&Option<T>` 转换为 `Option<&T>`。

```rust
let s: Option<String> = Some(String::from("Hello, Rustaceans!"));

let o: Option<usize> = Option::from(&s).map(|ss: &String| ss.len());

println!("Can still print s: {s:?}");

assert_eq!(o, Some(18));
```



#### From<&'a mut Option\<T>>

```rust
#[stable(feature = "option_ref_from_ref_option", since = "1.30.0")]
impl<'a, T> From<&'a mut Option<T>> for Option<&'a mut T> {
    fn from(o: &'a mut Option<T>) -> Option<&'a mut T> {
        o.as_mut()
    }
}
```

从 `&mut Option<T>` 转换为 `Option<&mut T>`

```rust
let mut s = Some(String::from("Hello"));
let o: Option<&mut String> = Option::from(&mut s);

match o {
    Some(t) => *t = String::from("Hello, Rustaceans!"),
    None => (),
}

assert_eq!(s, Some(String::from("Hello, Rustaceans!")));
```















