# 抽象类型

## 1.Trait 对象

在很多其它语言中，都有多态的概念。其中最灵活的就是面向对象范式下，父类型可以接收子类型做参数，从而实现一个函数在不同场景下表现不同行为。

比如说，`Duck`可以游泳，`Person`可以游泳，`Dog`也可以游泳，它们都有`swim`方法。那么面向对象中可以让这三个类都去继承一个`Swimmer`类，在函数参数中接收`Swimmer`的指针，实际上你可以传入任意它的子类型。



那么`Rust`是否有这样的语法？`Rust`本身不支持面向对象，但是它同样提供了类似的机制，这个机制就是`Trait`对象。

`Trait`对象是将拥有相同行为的类型集合，抽象为一个新类型。

比如说`Duck`、`Person`和`Dog`，这三个类型都实现了`Swimmer`特征，此时你就可以用`dyn Swimmer`类型作为参数，它可以接收任意实现了`Swimmer`特征的类型。

此处的`dyn Swimmer`就是一个`Trait`对象。

在 `Rust` 中，如果你希望一个函数参数能够接受任意实现了某个 `Trait` 的类型，可以使用 `Trait` 对象。`Trait` 对象的语法是：

```rust
dyn TraitName
```

这个语法可以用于函数参数，函数返回值等位置。

现在尝试实现刚才的案例：

```rust
trait Swimmer {
    fn swim(&self);
}

struct Duck;
struct Person;
struct Dog;

impl Swimmer for Duck {
    fn swim(&self) {
        println!("Duck paddles through the pond.");
    }
}

impl Swimmer for Person {
    fn swim(&self) {
        println!("Person swims freestyle.");
    }
}

impl Swimmer for Dog {
    fn swim(&self) {
        println!("Dog does the doggy paddle.");
    }
}
```

首先定义`Swimmer`特征，以及三个类型，并为三个类型分别实现`Swimmer`。

随后定义一个函数，接收`dyn Swimmer`：

```rust
fn perform_swim(swimmer: &dyn Swimmer) {
    swimmer.swim();
}
```

此处的`swimmer`参数就是一个`Trait`对象，尝试调用：

```rust
let duck = Duck;
let person = Person;
let dog = Dog;

perform_swim(&duck);
perform_swim(&person);
perform_swim(&dog);
```

::: tip `Trait`对象必须基于指针间接使用

以上代码可以成功运行，这就是`Trait`对象的最基本用法。

但是这里有一个小细节，我接受`Trait`对象的时候，使用了借用`&dyn Swimmer`，而不是直接接收，因为**`Trait`对象必须基于借用、指针、智能指针来间接使用**。如果你之前学的还不错，那应该想到了，这里和动态大小类型有关系。

对于一个`Trait`来说，往往可以被多种类型实现，而实现它的各种类型之间，大小可能是不同的。

比如说实现`Swimmer`的类型中，`Person`可能有`age`、`name`、`height`等等属性，而`Duck`有`color`之类的属性，这些属性就会导致`Person`和`Duck`两个类型占用的内存大小不同。

对于一个`dyn Swimmer`来说，它可能接收到的是任意实现它的类型，在运行前无法确定具体是哪一个，只能保证这个类型实现了`Swimmer`而已，因此`dyn Swimmer`可以视为一种动态大小类型。

动态大小类型不能直接在函数中使用，之前说过函数的栈帧大小在编译期就要确定，因此会通过一个指针来间接操作动态大小类型，比如借用、智能指针等等。

这是非常重要的知识点：

:::



### 1.1 虚表

指向`Trait`对象的指针是一个胖指针，它包含两部分：`data`和`v-ptr`。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b51ef82027b24134b19a511c8f6d5597.png#pic_center)

如图所示，这就是整个`Trait`对象的内存布局。在栈区存储的是一个借用指针，胖指针内包含`data`和`v-ptr`，这两个成员也是指针。`data`指向了堆区的`Self`，这是实现了这个`Trait`的具体类型，而`v-ptr`指向一个叫做`v-table`的表。

此处的`v-table`叫做虚表，`v-ptr`叫做虚表指针，这种叫法来源于`C++`。在虚表内，存储了关于`Self`的众多信息：

- 析构函数：回收内存时，可以调用这个函数回收`Self`的资源，避免内存泄露，这个会在后续博客详细讲解。
- `size`：`Self`占用内存字节数
- `对齐`：`Self`的对齐数，这涉及到内存的分配
- `方法`：`Self`实现的这个`Trait`的方法列表

举一个切实的例子：

```rust
trait Demo {
    fn func1(&self);
    fn func2(&self);
    fn func3(&self);
}

struct Type1 {
    x: u8,
    y: u32,
    z: [u8; 7],
}

#[repr(align(16))]
struct Type2 {
    p: u64,
    q: u8,
    r: [u64; 2],
}

impl Demo for Type1 {
    fn func1(&self) { println!("Type1::func1"); }
    fn func2(&self) { println!("Type1::func2"); }
    fn func3(&self) { println!("Type1::func3"); }
}

impl Demo for Type2 {
    fn func1(&self) { println!("Type2::func1"); }
    fn func2(&self) { println!("Type2::func2"); }
    fn func3(&self) { println!("Type2::func3"); }
}
```

现有一个`Demo`特征，`Type1`和`Type2`两个类型，并且`type2`强制对齐数为`16`，随后分别为两个类型实现了`Demo`。

两个`Trait`对象的内存布局如下：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2f6ed3f6e04547abbce226e78cc21f83.png#pic_center)

左侧的`Type1`的作为`Trait`对象的布局，右侧是`Type2`的。

首先`data`指针指向了各自堆区上的`Self`，这很好理解，基于这个指针可以访问到结构体内部的成员。

而`v-ptr`指向了`v-table`后，从上往下是析构函数的地址，大小，对齐数，以及方法列表。

`Type1`的大小是`12 byte`，对齐数是`4`，`Type2`的大小是`32`，对齐数是`16`，这个可以自行验证，都被放在了`v-table`中。

最后是`Demo`中的三个方法`func1`、`func2`、`func3`。不同类型的方法实现不同，那么它们的函数地址就不同，因此左右两个列表中，对应位置的函数地址就是不同的。

在本博客的最后，我会带着大家尝试验证这个布局是否正确，这有不小的难度，以及部分超纲知识。

有了`v-ptr`和`data`，`Trait`对象在调用方法的时候，就很容易的可以进行调用和传参。

例如：

```rust
fn process_func(demo: &dyn Demo) {
    demo.func1();
    demo.func2();
    demo.func3();
}
```

这个函数分别调用了`demo`的三个方法，问题是我编译期无法确定运行时`demo`具体是谁啊？我怎么知道调用哪一个类型的函数？此时`v-ptr`就发挥作用了。

以`func2`为例，回看刚才的布局图，你会发现不论`v-ptr`指向谁，在`v-table`中函数的布局顺序是固定的。此处的`v-table`是一个数组，而`func2`就在数组的第五个元素。不论谁实现了`Demo`这个`Trait`，最后`func2`一定是`v-ptr[4]`这个元素。

注：此处`v-ptr[4]`的语法，其实类似于C语言中的数组，数组名的本质是一个指针，`arr[4]`等效`*(arr + 4)`，这是一个指针先偏移，后解引用的过程。如果你没有这方面的基础，直接认为 `v-ptr[4]` 就是通过指针拿到数组的第五个元素即可。

那么`demo.func2()`会在编译期转化为以下等效的伪代码：

```rust
let (data, vptr) = demo; // 拆胖指针
let f = vptr[4];         // 偏移量 4 是 func2 的槽位
f(data);                 // 调用
```

首先从`demo`这个胖指针中拿出`v-ptr`，随后通过`v-ptr[4]`拿到`func2`的函数地址，最后`data`作为`self`传进函数中，并完成函数调用。

也就是说这个函数调用的过程，本质是不同类型传入的`v-ptr`不同，但是虚表的结构是相同的。因此不论`v-ptr`是哪一个类型的，都去拿表中指定偏移量位置的值，取出来做函数调用。

这个过程发生在运行时，也就是在运行时才能确定要调用的函数地址。这个过程需要查表传参，因此运行时效率会有所降低，对应的灵活性会提高。

这个运行时基于虚表和偏移量查找函数并调用的过程，称为`动态分发`。而动态的英文是`dynamic`，因此`Trait`对象使用了`dyn`这个关键字。在早期的`Rust`中没有`dyn`这个关键字，比如`& Swimmer`直接就是一个`Trait`对象，现在必须使用`dyn`来声明了。

最后，同一个类型的所有实例共用一张`v-table`，因为虚表内部的信息是完全固定的，整个程序运行期间都不会发生变化。

------

### 1.2 多 Trait 动态分发

在实际开发时，我们经常会希望对多个 `Trait` 进行动态分发，也就是：

- 某个类型同时实现了多个 `Trait`；
- 在运行时通过 Trait 对象来调用这些 trait 的方法（虚表调用）。

比如说，我们有一个 `Foo`：

```rust
trait Foo {
    fn foo(&self);
}
```

再加上一个标准库里的 `Debug`：

```rust
use std::fmt::Debug;
```

我们希望能写出“既是 `Foo` 又是 `Debug`”的动态分发对象，让调用方只拿着一个引用，就能同时调用这两个 `Trait` 的能力。换句话说，就是想要一个“打包了多个 Trait 的 Trait 对象”，在运行时通过虚表调用这些方法。接下来要做的，就是解决这个“多个 trait 动态分发”的场景。

这时候一个很直接的想法是：

既然一个类型实现了多个 `Trait`，那我能不能写一个“多个 Trait 的 Trait 对象”，比如：

```rust
fn call_foo(x: &dyn Foo + Debug) { /* ... */ }
```

直觉希望这是一个“`Foo` 的 Trait 对象，但要求它也实现 `Debug`”，然后在函数里既能调用 `foo()`，又能 `println!("{:?}", x)`。

但这种写法在现在的 Rust 里是行不通的：`&dyn Foo + Debug` 这种“在 trait object 类型上直接用 `+` 拼接多个 trait”的方式并不能完成我们想要的功能。

要想真正做到“一个 trait 对象上拥有多个 trait 的方法”，需要换一种思路：不用把多个 trait 直接拼在 `dyn` 后面，而是用**一个新的 trait 去继承所有需要的 trait**，把它们“打包”成一个组合 trait，然后只对这个组合 trait 做动态分发。

也就是说：

- 不要去拼 `&dyn Foo + Bar + Baz`；
- 而是定义一个新 trait，比如 `FooBarBaz`，让它继承 `Foo`、`Bar`、`Baz`；
- 之后就用 `&dyn FooBarBaz` 作为 trait 对象来完成多种方法的动态分发。

下面直接用代码演示这一整套写法。

首先定义几个基础 trait：

```rust
use std::fmt::Debug;

trait Foo {
    fn foo(&self);
}

trait Bar {
    fn bar(&self);
}
```

以及一个具体类型，实现它们：

```rust
#[derive(Debug)]
struct S;

impl Foo for S {
    fn foo(&self) {
        println!("Foo::foo() on S");
    }
}

impl Bar for S {
    fn bar(&self) {
        println!("Bar::bar() on S");
    }
}
```

现在我们希望有一个“既是 `Foo` 又是 `Bar` 并且还能 `Debug`”的 trait 对象，直接去写 `&dyn Foo + Bar + Debug` 不行，那就**自己定义一个组合 trait**：

```rust
trait FooBarDebug: Foo + Bar + Debug {}
```

这句话的意思是：

- 任何实现了 `FooBarDebug` 的类型，必须同时实现 `Foo`、`Bar` 和 `Debug`；
- `FooBarDebug` 相当于把这三个 trait 能力打包在一起，对外只暴露一个名字。

接着，为所有满足条件的类型自动实现这个组合 trait：

```rust
impl<T> FooBarDebug for T
where
    T: Foo + Bar + Debug
{}
```

这样，凡是实现了 `Foo + Bar + Debug` 的类型，都会自动被视为实现了 `FooBarDebug`，比如上面的 `S`。

现在我们就可以把“多个 trait 的动态分发”统一落到 `FooBarDebug` 这个组合 trait 上了：

```rust
fn call_all(x: &dyn FooBarDebug) {
    x.foo();
    x.bar();
    println!("{:?}", x);
}
```

这里的 `x: &dyn FooBarDebug` 就是我们真正想要的“多 trait 动态分发”的场景：

- `x.foo()` 来自 `Foo`；
- `x.bar()` 来自 `Bar`；
- `println!("{:?}", x)` 来自 `Debug`；
- 调用方只持有一个 `&dyn FooBarDebug` 的 trait 对象引用，就可以在运行时通过虚表调用这些方法。

调用示例：

```rust
fn main() {
    let s = S;
    call_all(&s); // &S 自动被转换成 &dyn FooBarDebug
}
```

这样一来，我们就用一个新的 trait 继承多个父 trait，把多种能力合并到了同一个 trait 对象上，实现了一个 trait 多种函数”的动态分发。

只要记住这条思路：想要多个 trait 动态分发，就新建一个组合 trait 来继承它们，再对这个组合 trait 做 trait 对象。



## 2.dyn-compatible

并不是所有的`Trait`都可以作为`Trait`对象使用，只有符合要求的才行。

具体要求参考官方文档：[Traits - The Rust Reference](https://doc.rust-lang.org/reference/items/traits.html#r-items.traits.dyn-compatible.intro)。

`Trait`对象必须符合以下要求：

> 1. 所有的 `Super Trait` 也必须是 `dyn-compatible`
> 2. `Trait`的`Self`类型参数不能被限定为`Sized`（不能继承`Sized`）
> 3. 不能有任何关联常量
> 4. 所有函数必须要么是可动态分发的函数，要么显式标记为不可调用
> 5. 不能有带泛型的关联类型

如果符合以上要求，就称为 `dyn-compatible`，就可以被作为 `Trait`对象使用。

接下来分点解释。

------

### 2.1 Sized

> Trait`的`Self`类型参数不能被限定为`Sized

`Sized`是一个原生的`Trait`，它表示一个类型的大小是固定的。与之对应的是`Unsize`，表示动态大小类型。

绝大部分`Trait`默认就是`?Sized`，它表示不限制`Self`的大小，既可以是`Sized`也可以是`Unsize`。

你可以显式的指定：

```rust
trait Demo: Sized {}
```

这个`Demo`继承了`Sized`，那么它就无法成为一个`Trait`对象。

为什么不能继承`Sized`？在`Rust`官方文档有这样一句话：

> Trait objects implement the base trait, its auto traits, and any supertraits of the base trait
> 译：特征对象会实现它的基 `Trait`、它的 `auto trait`，以及所有的 `Super Trait`

这句话来自：[Trait object types - The Rust Reference](https://doc.rust-lang.org/reference/types/trait-object.html)

简单来说，特征对象会实现它自己对应的`Trait`继承的所有`Trait`。

例如：

```rust
trait Demo: Display + Debug {
	fn func();
}
```

这是一个`Trait`，它继承了`Display`、`Debug`，这两个算作`Super trait`。它还隐式的继承了`?Sized`，这也属于`Super trait`。

那么对应的特征对象`dyn Demo`作为一个类型，它也会自动实现`Display`、`Debug`、`?Sized`这`Trait`，以及它自己`Demo`。

你有没有想过一个问题，动态分发的时候，为什么`Trait`对象可以随意的调用`Trait`内部的方法：

```rust
fn process_func(demo: &dyn Demo) {
    demo.func();
}
```

`dyn Demo`自己就是一个类型，它想要调用`Demo`这个`Trait`内部的`func`方法，它自己就必须实现`Demo`这个`Trait`，并满足所有`Self`的约束，因为此时`dyn Demo`本身就是`Self`。而这个过程，已经由`Rust`编译期自动帮你实现了。

假设`Demo`受到`Size`约束：

```rust
trait Demo: Sized {}
```

也就是`Self`收到`Sized`约束，如果需要`Trait` 对象，那么`dyn Demo`就要受到`Sized`约束。问题在于，`dyn Demo`是一个动态大小类型，它根本不可能有确定的大小，根本不可能受到`Sized`约束。

因此当一个`Trait`收到`Sized`约束，它不能使用`Trait`对象。

另外的，之前提到，如果想要一次性动态分发多个`Trait`。需要让一个`Trait`同时去继承多个`Trait`，这样就可以一次性对他们动态分发。本质上是因为所有被继承的都算`Super Trait`，因此`Trait`对象就会实现这些`Trait`，虚表就有他们的方法。

------

### 2.2 关联常量

> 不能有任何关联常量

不同实现者可以给同一个关联常量不同的值。

```rust
trait Foo {
	const A: i32;
}

impl Foo for u8  { const A: i32 = 1; }
impl Foo for u16 { const A: i32 = 2; }
```

如果你有一个 `Box<dyn Foo>`，那么问题来了： `dyn Foo::A` 应该是 `1` 还是 `2`？

在方法调用时，编译器可以通过 `v-table` 动态分发到正确的函数指针，但常量不是函数调用，无法通过`v-table`动态查找一个常量的值。所以编译器无法在运行时决定该取哪个值。

所以`Trait`对象要禁止关联常量，它无法进行动态分发。



### 2.3 可动态分发的函数

> 所有函数必须要么是可动态分发的函数，要么显式标记为不可调用

这里对于 "可动态分发的函数" 的定义又是一个非常复杂的条例，我们已经知道`Trait`对象会维护一张虚表，内部会存放元信息和众多方法地址。但并不是`Trait`内部所有的方法都会进入虚表，只有可通过`Trait`对象动态分发的方法才会进入虚表。

可动态分发的函数必须满足：

1. 不能有泛型参数
2. 必须使用`Self`或者可解引用为`Self`的类型作为第一个参数
3. 函数签名中，不能在第一个参数以外的位置使用`Self`
4. 返回值不能是不透明类型

如果不能满足以上条件，必须显式标记为不可调用。

分点一个一个讲解：

**1.不能有泛型参数**

当一个函数带有泛型参数，那么经过单态化后，它就可能派生出无数种具体实现。我们先前说过，动态分发的基础是`v-ptr`以及指定的偏移量，而这个又建立在同一个`Trait`所有类型的`v-table`格式是一模一样的基础上。

当使用泛型参数后，首先无法预知会单态化出多少个版本的函数，那么无论`v-table`有多大，都装不下这么多函数地址。其次，不同类型单态化出的版本不同，那么每个`v-table`格式就不一样了，这会撼动整个动态分发体系的根基。



**2.必须使用`Self`或者可解引用为`Self`的类型作为第一个参数**

动态分发过程中，从虚表拿到函数地址后，会把`data`作为第一个参数传入，如果函数第一个参数不是`Self`或者`Self`的指针，此时参数传递就会出错，直接错误。因此可动态分发的函数必须有`Self`作为第一个参数。



**3.函数签名中，不能在第一个参数以外的位置使用`Self`**

此处的第一个参数外，包括从第二个参数往后的所有参数，以及函数返回值都不能用`Self`相关的类型，比如`Self`、`&Self`等等。

看一个案例：

```rust
trait Test {
    fn merge(&self, other: &Self);
}

fn func(t1: &dyn Test, t2: &dyn Test) {
    t1.merge(t2);
}
```

此处的`Test`内部包含一个`merge`方法，第二个参数也是一个`&self`。假设通过`func`对其进行动态派发，`t1`和`t2`接受两个`&dyn Test`，然后进行`t1.merge(t2)`。

看起来很完美，没有什么逻辑问题？实际上这个代码根本经不起推敲。

对于`func`函数来说，它只保证`t1`和`t2`是实现了`Test`的类型，可不能保证`t1`和`t2`最终指向了相同的类型。

比如`A`和`B`两个类型都实现了`Test`，那么很有可能`t1`指向`A`，`t2`指向了`B`。此时`t1,merge(t2)`还合理吗？`t1`要求`other`的类型也应该是`A`，但是这种传法完全有可能把一个`B`传给了`other`。



**4.返回值不能是不透明类型**

这个会在一会讲解`impl Trait`时讲到。

只要满足以上四点，就是一个可动态分发的函数，它的地址就会进入虚表，从而实现动态分发。

如果说某个函数违背了以上要求，那么你必须显式标记为不可调用，最常见的手法是在方法中限制`Self: Sized`，这样这个函数就不会进入虚表。

但是如果某个函数违背了四条规则之一，并且还没有显式标注不可调用，那么整个`Trait`都将无法动态分发了。

例如：

```rust
trait Demo {
    fn demo(&self);
    fn func(&self, other: Self) -> Self;
}

struct Type1;

impl Demo for Type1 {
    fn demo(&self) {
        println!("Type1 demo");
    }

    fn func(&self, other: Type1) -> Type1 {
        println!("Type1 func");
        other
    }
}

fn process_demo(d: &dyn Demo) {
    d.demo();
}
```

在`Demo`中，它的`demo`函数是一个可动态分发的函数，满足所有要求。而`func`函数在其他位置出现了`Self`，它不可动态分发，还没有显式标注不可调用。那么整个`Demo`都无法作为`Trait`对象使用，`process_demo`中就算没有调用`func`方法，`d: &dyn Demo`这个语法也会报错。

想要解决，只需要在`func`中对`Self`进行限制：

```rust
trait Demo {
    fn demo(&self);
    fn func(&self, other: Self) -> Self
    where Self: Sized; // 添加 Trait 约束
}

struct Type1;

impl Demo for Type1 {
    fn demo(&self) {
        println!("Type1 demo");
    }

    fn func(&self, other: Type1) -> Type1
    where Self: Sized {  // 添加 Trait 约束
        println!("Type1 func");
        other
    }
}

fn process_demo(d: &dyn Demo) {
    d.demo();
}
```

在以上代码中的两处位置，添加了`Sized`约束，此时这个`func`函数就不会进入虚表，最后`demo`也就可以正常调用了。

------

### 2.4 泛型关联类型

> 不能有带泛型的关联类型

在理解完刚才的一点后，其实这个就很好理解了。关联类型往往会在对应的方法中进行使用，用户每指定一个泛型作为关联类型，就会单态化出一个新版的函数，最后导致`v-table`大小不确定，格式不一致，和之前不能有泛型参数是一个逻辑

------

### 2.5 总结

看到这里你估计已经头昏眼花了，我写的也快头昏眼花了。我把每个要点都拆出来理清了内部的逻辑，最后总结一下所有规则。

`dyn-compatible`的要求有：

1. 所有的 `Super Trait` 也必须是 `dyn-compatible`
2. `Trait`的`Self`类型参数不能被限定为`Sized`（不能继承`Sized`）
3. 不能有任何关联常量
4. 所有函数必须要么是可动态分发的函数，要么显式标记为不可调用。可动态分发的函数必须满足：
   - 不能有泛型参数
   - 必须使用`Self`或者可解引用为`Self`的类型作为第一个参数
   - 函数签名中，不能在第一个参数以外的位置使用`Self`
   - 返回值不能是不透明类型
5. 不能有带泛型的关联类型

------

## 3.impl Trait

在`Rust 2018`，又引入了一个新特性`impl Trait`。它也属于抽象类型，并且是静态分发的。它和`Trait`对象属于相反的特性。

在`Trait`对象中，基于指针把类型放到堆上管理，称为`装箱`。而`impl Trait`则会把值放到栈区，称为`拆箱`。前者是运行时动态分发，后者是编译期静态分发。

`impl Trait`也用于描述实现了某个`Trait`的类型，它可以放在函数参数和返回值中。但是不能用作 `let` 绑定、结构体字段类型或类型别名等位置。

### 3.1 函数参数

语法：

```rust
fn func(arg: impl Trait_1 + Trait_2);
```

此处的`arg`参数，就是一个受到约束的类型，它必须是实现了`Trait_1`和`Trait_2`的类型。

其实它等效与以下代码：

```rust
fn func<T: Trait_1 + Trait_2>(arg: T);
```

也就是之前的泛型约束，它们两个几乎是完全等价的。只是`impl Trait`语法下，不用显式写出泛型，更简洁。

它们也有相同的编译期单态化机制，当`func`函数传入多少种参数，最后就会单态化出多少实例。

但不同的是，泛型可以由用户自己指定，而`impl Trait`只能通过编译器自行推导。



### 3.2 返回值

语法：

```rust
fn func() -> impl Trait_1 + Trait_2;
```

此时`func`函数限制了返回的类型必须是同时实现了`Trait_1`和`Trait_2`的类型。

与泛型不同的是，泛型由调用方决定具体类型，而`impl Trait`是在函数内部自己决定返回类型的。

例如：

```rust
fn make_number() -> impl std::fmt::Display {
    42
}
```

最终返回的是一个`i32`类型，它实现了`std::fmt::Display`。

但是这不代表可以在一个函数中返回不同类型。例如：

```rust
fn make_number(num: i32) -> impl std::fmt::Display {
	if num > 0 {
		10
	} else {
		"hello"
	}
}
```

这个代码是错误的，你不能让一个函数返回多种类型。

那有人就有疑问了，既然如此为什么不直接把返回值写死，还要搞个`impl Trait`语法？

在返回值中`impl Trait`与其说是一个约束，不如说是一种承诺，承诺我的返回值一定是实现了某些`Trait`的类型。

当外部调用这个函数，拿到一个类型后。用户不必关心类型的具体值，只要知道它实现了某些`Trait`，并且可以使用这个`Trait`就好。

你可以尝试运行以下代码：

```rust
fn make_number() -> impl std::fmt::Display {
    42
}

let mut num = make_number();

println!("{}", num);
num += 10;
```

这行代码会报错，因为实现了`Display`的类型不一定可以使用`+=`。即便`num`真的是一个`i32`类型，但是在外层调用时，编译器认为`num`相当于一个`impl Display`的类型，你只能使用在`Display`范围内的方法。

甚至编译器不允许你去指定类型：

```rust
let mut num: impl Display = make_number();
let mut num: i32 = make_number();
```

这两个写法都是错误的，你既不能直接判断这是一个`i32`，甚至你不能说它是一个`impl Display`，只能让编译器自己去推出它是一个`impl Display`。

这种类型就是刚才说的`不透明类型`，你只知道这个类型具有某些特征，但不会让你知道这个类型具体是什么，从而实现封装。

在后续学习中，比如闭包这一块内容，你很难去写出一个类型，有一些类型是编译器生成的`匿名类型`，非常复杂。但是你只要知道这个类型实现了某些`Trait`，然后用`impl Trait`语法来使用它，到时候才能感受到这个语法的实际作用。

现在的主要作用，可以理解为部分场景下可以简化泛型，提高代码可读性。







## 4.验证虚表 与 模拟动态分发

博客的最后，如果你有兴趣，可以一起往下用代码验证虚表的存在。

使用的案例是之前的`Demo`：

```rust
trait Demo {
    fn func1(&self);
    fn func2(&self);
    fn func3(&self);
}

struct Type1 {
    x: u8,
    y: u32,
    z: [u8; 7],
}

#[repr(align(16))]
struct Type2 {
    p: u64,
    q: u8,
    r: [u64; 2],
}

impl Demo for Type1 {
    fn func1(&self) { println!("Type1::func1 调用完毕"); }
    fn func2(&self) { println!("Type1::func2 调用完毕"); }
    fn func3(&self) { println!("Type1::func3 调用完毕"); }
}

impl Demo for Type2 {
    fn func1(&self) { println!("Type2::func1 调用完毕"); }
    fn func2(&self) { println!("Type2::func2 调用完毕"); }
    fn func3(&self) { println!("Type2::func3 调用完毕"); }
}
```

- 输出真实信息：

```rust
// 打印真实元信息
fn print_real_info<T: Demo>() {
    let f1: fn(&T) = T::func1;
    let f2: fn(&T) = T::func2;
    let f3: fn(&T) = T::func3;

    println!("=== 真实信息 ===");
    println!("size: {} align: {}", size_of::<T>(), align_of::<T>());
    println!("func1: {:p}", f1 as *const ());
    println!("func2: {:p}", f2 as *const ());
    println!("func3: {:p}", f3 as *const ());
}
```

这是第一个函数，用于输出某个类型的真实信息，包括`size`，对齐数，以及三个函数的地址。其中`fn (&T)`是一个函数指针类型，会在后续博客深入讲解。使用`{:p}`就可以输出这个指针指向的具体地址，也就是函数的地址。

- 输出虚表信息：

```rust
unsafe fn print_vtable_info<T: Demo>(obj: &dyn Demo) {
	// 拆解胖指针
    let raw = obj as *const dyn Demo;
    let (data, vptr): (*const (), *const ()) = transmute(raw);
    let data: &T = transmute(data);
    let vt = vptr as *const *const ();
	
	// ...
}
```

首先定义一个 `print_vtable_info` 函数，它被`unsafe`修饰，表示内部会进行一些不安全操作。接收一个`&dym Demo`，这是一个胖指针，函数开头先把胖指针中的`data`和`vtable`拆解出来。

```rust
let raw = obj as *const dyn Demo;
```

这行代码的意思是把`obj`转化为一个原生指针，`*const`是一种原生指针，会在后续博客讲解，基于这种指针可以进行一些类似C语言的不安全操作。`*const`后面接着的是它具体指向的类型，`*const dyn Demo`就是一个指向`Demo`特征对象的指针。

```rust
let (data, vptr): (*const (), *const ()) = transmute(raw);
```

这里用到了一个`transmute`方法，它类似于强制类型转化，强行把`raw`内部的信息解释为`(*const (), *const ())`这个类型。而`*const ()`是指向一个单元类型的原生指针，可以理解为C语言中的`void*`。也就是说这里我不在乎它具体指向什么类型，我只是要把两个指针拿出来而已。

```rust
let data: &T = transmute(data);
```

这里也是基于 `transmute`，把`data`转化为`&T`这个类型，也就是`&self`，后续才能正常传参。

```rust
let vt = vptr as *const *const ();
```

这行代码是通过`v-ptr`拿到虚函数表，而`*const *const ()`可以看作一个二级指针，它指向的是`*const ()`的指针。

为什么这里要用二级指针？可以看以下布局：

![在这里插入图片描述](https://gitee.com/xarzhi/picture/raw/master/img/26fbf36e1ce14d4a89acedcbbe380f5a.png)

我把所有变量名都变为了具体的数值，`0x`开头的是十六进制的地址。

一开始我们从胖指针中拆出了`v-ptr`，它的值就是整个`v-table`的起始地址`0x11223340`。对它直接解引用，拿到的就是`0x66778899`这个地址，也就是析构函数的地址。但是目前它是`*const ()`类型，解引用拿到的是一个单元类型，而我们期望解引用之后还是一个指针。因此把他转为`*const *const ()`类型。此时对其解引用，拿到的就是`*const ()`类型，还是一个指针，那么`0x66778899`这个地址就会被解释为一个指针，方便我们进行后续操作了。（这地方真挺绕的，有`C/C++`指针经验的同学会更好理解）。

这个过程我们只是修改它的类型，从而保证解引用后拿到的值会被解析为一个指针。

拆完胖指针，接下来基于`vt`提取出重要信息：

```rust
unsafe fn print_vtable_info<T: Demo>(obj: &dyn Demo) {
    // 拆胖指针

    // 提取信息
    let drop_fn: unsafe fn(*mut ()) = transmute(*vt.add(0));
    let size = *vt.add(1) as usize;
    let align = *vt.add(2) as usize;

    let f1: fn (&T) = transmute(*vt.add(3));
    let f2: fn (&T) = transmute(*vt.add(4));
    let f3: fn (&T) = transmute(*vt.add(5));
    
    // ...
}
```

这部分将函数地址和元信息都从虚表中提取了出来。

```rust
let drop_fn: unsafe fn(*mut ()) = transmute(*vt.add(0));
```

这里提取出析构函数的地址。`*vt.add(0)`中，`vt`本身已经指向第一个元素，`add(0)`不修改指针大小，随后对指针解引用，拿到了一个`*const ()`的指针。基于 `transmute` 函数，强行把这个指针的类型转化为 `unsafe fn(*mut ())`，这是一个函数指针，这里不讲解为什么是这样的格式，你只要知道`drop_fn`现在是一个指向析构函数的指针就好了。

```rust
let size = *vt.add(1) as usize;
let align = *vt.add(2) as usize;
```

这里提取出虚表中的`size`字段，也就是第二个元素。`*vt.add(1)`，先把`vt`的指针往后偏移一个元素的位置，此时它指向第二个元素，再对其解引用，就拿到了第二个元素的值。但是类型是`*const ()`，于是使用`as usize`强行把它转换为一个数字，这样就拿到了`size`。

下一行的`align`同理。

```rust
let f1: fn (&T) = transmute(*vt.add(3));
let f2: fn (&T) = transmute(*vt.add(4));
let f3: fn (&T) = transmute(*vt.add(5));
```

这里是拆出三个指针，实际上是三个函数指针，类型是 `fn (&T)`。通过`*vt.add(偏移量)`拿到对应偏移量的值，并通过 `transmute` 强制转化为函数指针类型。

到此为止所有有难度的内容都完成了，最后输出这些信息：

```rust
unsafe fn print_vtable_info<T: Demo>(obj: &dyn Demo) {
    // 拆胖指针

    // 提取信息

    println!("\n== 基于虚表调用函数 ==");
    f1(data);
    f2(data);
    f3(data);

    println!("\n== 虚表信息 ==");
    println!("data:   {:p}", data);
    println!("vptr: {:p}", vptr);

    println!("  [元信息]");
    println!("  drop fn: {:p}", drop_fn as *const ());
    println!("  size:    {}", size);
    println!("  align:   {}", align);

    println!("  [函数表]");
    println!("  func1: {:p}", f1);
    println!("  func2: {:p}", f2);
    println!("  func3: {:p}", f3);
}
```

首先直接拿`f1`、`f2`、`f3`去调用函数：

```rust
println!("\n== 基于虚表调用函数 ==");
f1(data);
f2(data);
f3(data);
```

这个过程已经是在模拟动态分发了，我们通过`v-ptr`、`data`、偏移量，终于凑齐了调用这个函数的所有必要条件，此时可以直接进行函数调用。

后续就是输出各种之前存储的信息，比如元数据，函数表地址等等。

在`main`函数中调用：

```rust
fn main() {
    let obj1: Box<dyn Demo> = Box::new(Type1 { x: 1, y: 2, z: [0; 7] });
    let obj2: Box<dyn Demo> = Box::new(Type2 { p: 2, q: 1, r: [0; 2] });

    // Type1
    println!("验证 Type1: ");
    print_real_info::<Type1>();
    unsafe { print_vtable_info::<Type1>(&*obj1); }

    // Type2
    println!("验证 Type2: ");
    print_real_info::<Type2>();
    unsafe { print_vtable_info::<Type2>(&*obj2); }
}
```

首先定义了两个`Trait`对象，随后调用`print_real_info`输出真实信息，再调用 `print_vtable_info` 输出虚表中的信息。

输出结果：

```rust
验证 Type1:
=== 真实信息 ===
size: 12 align: 4
func1: 0x7ff7ad013b40
func2: 0x7ff7ad013b70
func3: 0x7ff7ad013ba0

== 基于虚表调用函数 ==
Type1::func1 调用完毕
Type1::func2 调用完毕
Type1::func3 调用完毕

== 虚表信息 ==
data:   0x20aabc43130
vptr: 0x7ff7ad02bce0
  [元信息]
  drop fn: 0x0
  size:    12
  align:   4
  [函数表]
  func1: 0x7ff7ad013b40
  func2: 0x7ff7ad013b70
  func3: 0x7ff7ad013ba0
验证 Type2:
=== 真实信息 ===
size: 32 align: 16
func1: 0x7ff7ad013bd0
func2: 0x7ff7ad013c00
func3: 0x7ff7ad013c30

== 基于虚表调用函数 ==
Type2::func1 调用完毕
Type2::func2 调用完毕
Type2::func3 调用完毕

== 虚表信息 ==
data:   0x20aabc44200
vptr: 0x7ff7ad02bd10
  [元信息]
  drop fn: 0x0
  size:    32
  align:   16
  [函数表]
  func1: 0x7ff7ad013bd0
  func2: 0x7ff7ad013c00
  func3: 0x7ff7ad013c30
```

可以看到，真实信息和虚表中提取出来的信息是完全一致的。并且我们手动实现的动态分发也完成了最终的函数调用。

总代码：

```rust
use std::mem::{align_of, size_of, transmute};

trait Demo {
    fn func1(&self);
    fn func2(&self);
    fn func3(&self);
}

struct Type1 {
    x: u8,
    y: u32,
    z: [u8; 7],
}

#[repr(align(16))]
struct Type2 {
    p: u64,
    q: u8,
    r: [u64; 2],
}

impl Demo for Type1 {
    fn func1(&self) { println!("Type1::func1 调用完毕"); }
    fn func2(&self) { println!("Type1::func2 调用完毕"); }
    fn func3(&self) { println!("Type1::func3 调用完毕"); }
}

impl Demo for Type2 {
    fn func1(&self) { println!("Type2::func1 调用完毕"); }
    fn func2(&self) { println!("Type2::func2 调用完毕"); }
    fn func3(&self) { println!("Type2::func3 调用完毕"); }
}

// 打印真实元信息
fn print_real_info<T: Demo>() {
    let f1: fn(&T) = T::func1;
    let f2: fn(&T) = T::func2;
    let f3: fn(&T) = T::func3;

    println!("=== 真实信息 ===");
    println!("size: {} align: {}", size_of::<T>(), align_of::<T>());
    println!("func1: {:p}", f1 as *const ());
    println!("func2: {:p}", f2 as *const ());
    println!("func3: {:p}", f3 as *const ());
}

// 打印虚表信息（drop/size/align + vtable 方法地址）
unsafe fn print_vtable_info<T: Demo>(obj: &dyn Demo) {
    // 拆胖指针
    let raw = obj as *const dyn Demo;
    let (data, vptr): (*const (), *const ()) = transmute(raw);
    let data: &T = transmute(data);
    let vt = vptr as *const *const ();

    // 提取信息
    let drop_fn: unsafe fn(*mut ()) = transmute(*vt.add(0));
    let size = *vt.add(1) as usize;
    let align = *vt.add(2) as usize;

    let f1: fn (&T) = transmute(*vt.add(3));
    let f2: fn (&T) = transmute(*vt.add(4));
    let f3: fn (&T) = transmute(*vt.add(5));

    println!("\n== 基于虚表调用函数 ==");
    f1(data);
    f2(data);
    f3(data);

    println!("\n== 虚表信息 ==");
    println!("data:   {:p}", data);
    println!("vptr: {:p}", vptr);

    println!("  [元信息]");
    println!("  drop fn: {:p}", drop_fn as *const ());
    println!("  size:    {}", size);
    println!("  align:   {}", align);

    println!("  [函数表]");
    println!("  func1: {:p}", f1);
    println!("  func2: {:p}", f2);
    println!("  func3: {:p}", f3);
}

fn main() {
    let obj1: Box<dyn Demo> = Box::new(Type1 { x: 1, y: 2, z: [0; 7] });
    let obj2: Box<dyn Demo> = Box::new(Type2 { p: 2, q: 1, r: [0; 2] });

    // Type1
    println!("验证 Type1: ");
    print_real_info::<Type1>();
    unsafe { print_vtable_info::<Type1>(&*obj1); }

    // Type2
    println!("验证 Type2: ");
    print_real_info::<Type2>();
    unsafe { print_vtable_info::<Type2>(&*obj2); }
}
```