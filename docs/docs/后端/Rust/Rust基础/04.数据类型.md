# 数据类型



## 1.标量类型

**标量**（*scalar*）类型代表一个单独的值。Rust 有四种基本的标量类型：整型、浮点型、布尔类型和字符类型。



### 1.1 整形

**整数** 是一个没有小数部分的数字。

#### 1.1.1 整形类型

该类型声明表明，它关联的值应该是一个占据 32 比特位的无符号整数（有符号整数类型以 `i` 开头而不是 `u`）。

下表展示了 Rust 内建的整数类型。在有符号列和无符号列中的每一个变体（例如，`i16`）都可以用来声明整数值的类型。

| 长度    | 有符号  | 无符号  |
| ------- | ------- | ------- |
| 8-bit   | `i8`    | `u8`    |
| 16-bit  | `i16`   | `u16`   |
| 32-bit  | `i32`   | `u32`   |
| 64-bit  | `i64`   | `u64`   |
| 128-bit | `i128`  | `u128`  |
| arch    | `isize` | `usize` |

每一个变体都可以是有符号或无符号的，并有一个明确的大小。

**有符号** 和 **无符号** 代表数字能否为负值，换句话说，数字是否需要有一个符号（有符号数），或者永远为正而不需要符号（无符号数）。这有点像在纸上书写数字：当需要考虑符号的时候，数字以加号或减号作为前缀；然而，可以安全地假设为正数时，加号前缀通常省略。有符号数以[补码形式（two’s complement representation）](https://en.wikipedia.org/wiki/Two's_complement) 存储。

#### 1.1.2 存储空间

- 每一个有符号的变体可以储存包含从 -(2<sup>n-1</sup>) 到 2<sup>n-1</sup> - 1 在内的数字，这里 *n* 是变体使用的位数。所以 `i8` 可以储存从 -(27) 到 27 - 1 在内的数字，也就是从 -128 到 127。
- 无符号的变体可以储存从 0 到 2n - 1 的数字，所以 `u8` 可以储存从 0 到 28 - 1 的数字，也就是从 0 到 255。

另外，`isize` 和 `usize` 类型依赖运行程序的计算机架构：

- 64 位架构上它们是 64 位的
- 32 位架构上它们是 32 位的。

| 有符号  | 所占空间                                                     | 无符号  | 所占空间                                                     |
| ------- | ------------------------------------------------------------ | ------- | ------------------------------------------------------------ |
| `i8`    | -2<sup>7</sup>  到  2<sup>7</sup>-1                          | `u8`    | 0  到  2<sup>7</sup>-1                                       |
| `i16`   | -2<sup>15</sup>  到  2<sup>15</sup>-1                        | `u16`   | 0  到  2<sup>15</sup>-1                                      |
| `i32`   | -2<sup>31</sup>  到  2<sup>31</sup>-1                        | `u32`   | 0  到  2<sup>31</sup>-1                                      |
| `i64`   | -2<sup>63</sup>  到  2<sup>63</sup>-1                        | `u64`   | 0  到  2<sup>63</sup>-1                                      |
| `i128`  | -2<sup>125</sup>  到  2<sup>125</sup>-1                      | `u128`  | 0  到  2<sup>125</sup>-1                                     |
| `isize` | 32位系统：-2<sup>31</sup>  到  2<sup>31</sup>-1<br>64位系统：-2<sup>63</sup>  到  2<sup>63</sup>-1 | `usize` | 32位系统：0  到  2<sup>31</sup>-1<br/>64位系统：0  到  2<sup>63</sup>-1 |



可以使用下表中的任何一种形式编写数字字面值。注意除 byte 以外的所有数字字面值允许使用类型后缀，例如 `57u8`，同时也允许使用 `_` 做为分隔符以方便读数，例如`1_000`。

| 数字字面值       | 例子          |
| ---------------- | ------------- |
| Decimal          | `98_222`      |
| Hex              | `0xff`        |
| Octal            | `0o77`        |
| Binary           | `0b1111_0000` |
| Byte (`u8` only) | `b'A'`        |

```rust
fn main() {
    let decimal = 98_222;
    let hex = 0xff;
    let octal = 0o77;
    let binary = 0b1111_0000;
    let byte = b'A';
}
```

那么该使用哪种类型的数字呢？如果拿不定主意，Rust 的默认类型通常就很好，数字类型默认是 `i32`：它通常是最快的，甚至在 64 位系统上也是。`isize` 或 `usize` 主要作为某些集合的索引。



:::tip

##### [整型溢出](https://rust.bootcss.com/ch03-02-data-types.html#整型溢出)

比方说有一个 `u8` ，它可以存放从零到 `255` 的值。那么当你将其修改为 `256` 时会发生什么呢？这被称为 “整型溢出”（“integer overflow” ），关于这一行为 Rust 有一些有趣的规则。当在 debug 模式编译时，Rust 检查这类问题并使程序 *panic*，这个术语被 Rust 用来表明程序因错误而退出。第九章 [“`panic!` 与不可恢复的错误”](https://rust.bootcss.com/ch09-01-unrecoverable-errors-with-panic.html) 部分会详细介绍 panic。

在 release 构建中，Rust 不检测溢出，相反会进行一种被称为二进制补码包装（*two’s complement wrapping*）的操作。简而言之，`256` 变成 `0`，`257` 变成 `1`，依此类推。依赖整型溢出被认为是一种错误，即便可能出现这种行为。如果你确实需要这种行为，标准库中有一个类型显式提供此功能，[`Wrapping`](https://rust.bootcss.com/std/num/struct.Wrapping.html)。

:::





### 1.2 浮点型



